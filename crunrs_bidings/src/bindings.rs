/* automatically generated by rust-bindgen 0.65.1 */

# [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct __BindgenBitfieldUnit < Storage > { storage : Storage , } impl < Storage > __BindgenBitfieldUnit < Storage > { # [inline] pub const fn new (storage : Storage) -> Self { Self { storage } } } impl < Storage > __BindgenBitfieldUnit < Storage > where Storage : AsRef < [u8] > + AsMut < [u8] >, { # [inline] pub fn get_bit (& self , index : usize) -> bool { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = self . storage . as_ref () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [inline] pub fn set_bit (& mut self , index : usize , val : bool) { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; if val { * byte |= mask ; } else { * byte &= ! mask ; } } # [inline] pub fn get (& self , bit_offset : usize , bit_width : u8) -> u64 { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; let mut val = 0 ; for i in 0 .. (bit_width as usize) { if self . get_bit (i + bit_offset) { let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [inline] pub fn set (& mut self , bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; for i in 0 .. (bit_width as usize) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; self . set_bit (index + bit_offset , val_bit_is_set) ; } } } pub const HAVE_ATOMIC_INT : u32 = 1 ; pub const HAVE_CAP : u32 = 1 ; pub const HAVE_COPY_FILE_RANGE : u32 = 1 ; pub const HAVE_DLFCN_H : u32 = 1 ; pub const HAVE_DLOPEN : u32 = 1 ; pub const HAVE_EBPF : u32 = 1 ; pub const HAVE_ERROR_H : u32 = 1 ; pub const HAVE_FGETPWENT_R : u32 = 1 ; pub const HAVE_FGETXATTR : u32 = 1 ; pub const HAVE_FSCONFIG_CMD_CREATE_LINUX_MOUNT_H : u32 = 1 ; pub const HAVE_FSCONFIG_CMD_CREATE_SYS_MOUNT_H : u32 = 1 ; pub const HAVE_INTTYPES_H : u32 = 1 ; pub const HAVE_LINUX_BPF_H : u32 = 1 ; pub const HAVE_LINUX_IOPRIO_H : u32 = 1 ; pub const HAVE_LINUX_OPENAT2_H : u32 = 1 ; pub const HAVE_MEMFD_CREATE : u32 = 1 ; pub const HAVE_SD_NOTIFY_BARRIER : u32 = 1 ; pub const HAVE_SECCOMP : u32 = 1 ; pub const HAVE_SECCOMP_GET_NOTIF_SIZES : u32 = 1 ; pub const HAVE_SECCOMP_H : u32 = 1 ; pub const HAVE_STATX : u32 = 1 ; pub const HAVE_STDATOMIC_H : u32 = 1 ; pub const HAVE_STDINT_H : u32 = 1 ; pub const HAVE_STDIO_H : u32 = 1 ; pub const HAVE_STDLIB_H : u32 = 1 ; pub const HAVE_STRINGS_H : u32 = 1 ; pub const HAVE_STRING_H : u32 = 1 ; pub const HAVE_SYSTEMD : u32 = 1 ; pub const HAVE_SYSTEMD_SD_BUS_H : u32 = 1 ; pub const HAVE_SYS_CAPABILITY_H : u32 = 1 ; pub const HAVE_SYS_STAT_H : u32 = 1 ; pub const HAVE_SYS_TYPES_H : u32 = 1 ; pub const HAVE_UNISTD_H : u32 = 1 ; pub const HAVE_YAJL : u32 = 1 ; pub const LT_OBJDIR : & [u8 ; 7usize] = b".libs/\0" ; pub const PACKAGE : & [u8 ; 5usize] = b"crun\0" ; pub const PACKAGE_BUGREPORT : & [u8 ; 22usize] = b"giuseppe@scrivano.org\0" ; pub const PACKAGE_NAME : & [u8 ; 5usize] = b"crun\0" ; pub const PACKAGE_STRING : & [u8 ; 24usize] = b"crun 1.15.0.0.0.13-700e\0" ; pub const PACKAGE_TARNAME : & [u8 ; 5usize] = b"crun\0" ; pub const PACKAGE_URL : & [u8 ; 1usize] = b"\0" ; pub const PACKAGE_VERSION : & [u8 ; 19usize] = b"1.15.0.0.0.13-700e\0" ; pub const SECCOMP_ARCH_RESOLVE_NAME : u32 = 1 ; pub const SHARED_LIBCRUN : u32 = 1 ; pub const STDC_HEADERS : u32 = 1 ; pub const VERSION : & [u8 ; 19usize] = b"1.15.0.0.0.13-700e\0" ; pub const _SYS_TYPES_H : u32 = 1 ; pub const _FEATURES_H : u32 = 1 ; pub const _DEFAULT_SOURCE : u32 = 1 ; pub const __GLIBC_USE_ISOC2X : u32 = 0 ; pub const __USE_ISOC11 : u32 = 1 ; pub const __USE_ISOC99 : u32 = 1 ; pub const __USE_ISOC95 : u32 = 1 ; pub const __USE_POSIX_IMPLICITLY : u32 = 1 ; pub const _POSIX_SOURCE : u32 = 1 ; pub const _POSIX_C_SOURCE : u32 = 200809 ; pub const __USE_POSIX : u32 = 1 ; pub const __USE_POSIX2 : u32 = 1 ; pub const __USE_POSIX199309 : u32 = 1 ; pub const __USE_POSIX199506 : u32 = 1 ; pub const __USE_XOPEN2K : u32 = 1 ; pub const __USE_XOPEN2K8 : u32 = 1 ; pub const _ATFILE_SOURCE : u32 = 1 ; pub const __WORDSIZE : u32 = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1 ; pub const __SYSCALL_WORDSIZE : u32 = 64 ; pub const __TIMESIZE : u32 = 64 ; pub const __USE_MISC : u32 = 1 ; pub const __USE_ATFILE : u32 = 1 ; pub const __USE_FORTIFY_LEVEL : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_SCANF : u32 = 0 ; pub const __GLIBC_USE_C2X_STRTOL : u32 = 0 ; pub const _STDC_PREDEF_H : u32 = 1 ; pub const __STDC_IEC_559__ : u32 = 1 ; pub const __STDC_IEC_60559_BFP__ : u32 = 201404 ; pub const __STDC_IEC_559_COMPLEX__ : u32 = 1 ; pub const __STDC_IEC_60559_COMPLEX__ : u32 = 201404 ; pub const __STDC_ISO_10646__ : u32 = 201706 ; pub const __GNU_LIBRARY__ : u32 = 6 ; pub const __GLIBC__ : u32 = 2 ; pub const __GLIBC_MINOR__ : u32 = 39 ; pub const _SYS_CDEFS_H : u32 = 1 ; pub const __glibc_c99_flexarr_available : u32 = 1 ; pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI : u32 = 0 ; pub const __HAVE_GENERIC_SELECTION : u32 = 1 ; pub const _BITS_TYPES_H : u32 = 1 ; pub const _BITS_TYPESIZES_H : u32 = 1 ; pub const __OFF_T_MATCHES_OFF64_T : u32 = 1 ; pub const __INO_T_MATCHES_INO64_T : u32 = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : u32 = 1 ; pub const __STATFS_MATCHES_STATFS64 : u32 = 1 ; pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 : u32 = 1 ; pub const __FD_SETSIZE : u32 = 1024 ; pub const _BITS_TIME64_H : u32 = 1 ; pub const __clock_t_defined : u32 = 1 ; pub const __clockid_t_defined : u32 = 1 ; pub const __time_t_defined : u32 = 1 ; pub const __timer_t_defined : u32 = 1 ; pub const _BITS_STDINT_INTN_H : u32 = 1 ; pub const __BIT_TYPES_DEFINED__ : u32 = 1 ; pub const _ENDIAN_H : u32 = 1 ; pub const _BITS_ENDIAN_H : u32 = 1 ; pub const __LITTLE_ENDIAN : u32 = 1234 ; pub const __BIG_ENDIAN : u32 = 4321 ; pub const __PDP_ENDIAN : u32 = 3412 ; pub const _BITS_ENDIANNESS_H : u32 = 1 ; pub const __BYTE_ORDER : u32 = 1234 ; pub const __FLOAT_WORD_ORDER : u32 = 1234 ; pub const LITTLE_ENDIAN : u32 = 1234 ; pub const BIG_ENDIAN : u32 = 4321 ; pub const PDP_ENDIAN : u32 = 3412 ; pub const BYTE_ORDER : u32 = 1234 ; pub const _BITS_BYTESWAP_H : u32 = 1 ; pub const _BITS_UINTN_IDENTITY_H : u32 = 1 ; pub const _SYS_SELECT_H : u32 = 1 ; pub const __sigset_t_defined : u32 = 1 ; pub const __timeval_defined : u32 = 1 ; pub const _STRUCT_TIMESPEC : u32 = 1 ; pub const FD_SETSIZE : u32 = 1024 ; pub const _BITS_PTHREADTYPES_COMMON_H : u32 = 1 ; pub const _THREAD_SHARED_TYPES_H : u32 = 1 ; pub const _BITS_PTHREADTYPES_ARCH_H : u32 = 1 ; pub const __SIZEOF_PTHREAD_MUTEX_T : u32 = 40 ; pub const __SIZEOF_PTHREAD_ATTR_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_RWLOCK_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_BARRIER_T : u32 = 32 ; pub const __SIZEOF_PTHREAD_MUTEXATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_COND_T : u32 = 48 ; pub const __SIZEOF_PTHREAD_CONDATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : u32 = 8 ; pub const __SIZEOF_PTHREAD_BARRIERATTR_T : u32 = 4 ; pub const _THREAD_MUTEX_INTERNAL_H : u32 = 1 ; pub const __PTHREAD_MUTEX_HAVE_PREV : u32 = 1 ; pub const __have_pthread_attr_t : u32 = 1 ; pub const _STDINT_H : u32 = 1 ; pub const __GLIBC_USE_LIB_EXT2 : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : u32 = 0 ; pub const _BITS_WCHAR_H : u32 = 1 ; pub const _BITS_STDINT_UINTN_H : u32 = 1 ; pub const _BITS_STDINT_LEAST_H : u32 = 1 ; pub const INT8_MIN : i32 = - 128 ; pub const INT16_MIN : i32 = - 32768 ; pub const INT32_MIN : i32 = - 2147483648 ; pub const INT8_MAX : u32 = 127 ; pub const INT16_MAX : u32 = 32767 ; pub const INT32_MAX : u32 = 2147483647 ; pub const UINT8_MAX : u32 = 255 ; pub const UINT16_MAX : u32 = 65535 ; pub const UINT32_MAX : u32 = 4294967295 ; pub const INT_LEAST8_MIN : i32 = - 128 ; pub const INT_LEAST16_MIN : i32 = - 32768 ; pub const INT_LEAST32_MIN : i32 = - 2147483648 ; pub const INT_LEAST8_MAX : u32 = 127 ; pub const INT_LEAST16_MAX : u32 = 32767 ; pub const INT_LEAST32_MAX : u32 = 2147483647 ; pub const UINT_LEAST8_MAX : u32 = 255 ; pub const UINT_LEAST16_MAX : u32 = 65535 ; pub const UINT_LEAST32_MAX : u32 = 4294967295 ; pub const INT_FAST8_MIN : i32 = - 128 ; pub const INT_FAST16_MIN : i64 = - 9223372036854775808 ; pub const INT_FAST32_MIN : i64 = - 9223372036854775808 ; pub const INT_FAST8_MAX : u32 = 127 ; pub const INT_FAST16_MAX : u64 = 9223372036854775807 ; pub const INT_FAST32_MAX : u64 = 9223372036854775807 ; pub const UINT_FAST8_MAX : u32 = 255 ; pub const UINT_FAST16_MAX : i32 = - 1 ; pub const UINT_FAST32_MAX : i32 = - 1 ; pub const INTPTR_MIN : i64 = - 9223372036854775808 ; pub const INTPTR_MAX : u64 = 9223372036854775807 ; pub const UINTPTR_MAX : i32 = - 1 ; pub const PTRDIFF_MIN : i64 = - 9223372036854775808 ; pub const PTRDIFF_MAX : u64 = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : i32 = - 2147483648 ; pub const SIG_ATOMIC_MAX : u32 = 2147483647 ; pub const SIZE_MAX : i32 = - 1 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 4294967295 ; pub const _STDLIB_H : u32 = 1 ; pub const WNOHANG : u32 = 1 ; pub const WUNTRACED : u32 = 2 ; pub const WSTOPPED : u32 = 2 ; pub const WEXITED : u32 = 4 ; pub const WCONTINUED : u32 = 8 ; pub const WNOWAIT : u32 = 16777216 ; pub const __WNOTHREAD : u32 = 536870912 ; pub const __WALL : u32 = 1073741824 ; pub const __WCLONE : u32 = 2147483648 ; pub const __W_CONTINUED : u32 = 65535 ; pub const __WCOREFLAG : u32 = 128 ; pub const __HAVE_FLOAT128 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT128 : u32 = 0 ; pub const __HAVE_FLOAT64X : u32 = 1 ; pub const __HAVE_FLOAT64X_LONG_DOUBLE : u32 = 1 ; pub const __HAVE_FLOAT16 : u32 = 0 ; pub const __HAVE_FLOAT32 : u32 = 1 ; pub const __HAVE_FLOAT64 : u32 = 1 ; pub const __HAVE_FLOAT32X : u32 = 1 ; pub const __HAVE_FLOAT128X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT16 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT32 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT64 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT32X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT64X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT128X : u32 = 0 ; pub const __HAVE_FLOATN_NOT_TYPEDEF : u32 = 0 ; pub const __ldiv_t_defined : u32 = 1 ; pub const __lldiv_t_defined : u32 = 1 ; pub const RAND_MAX : u32 = 2147483647 ; pub const EXIT_FAILURE : u32 = 1 ; pub const EXIT_SUCCESS : u32 = 0 ; pub const _ALLOCA_H : u32 = 1 ; pub const __bool_true_false_are_defined : u32 = 1 ; pub const true_ : u32 = 1 ; pub const false_ : u32 = 0 ; pub const _STDIO_H : u32 = 1 ; pub const _____fpos_t_defined : u32 = 1 ; pub const ____mbstate_t_defined : u32 = 1 ; pub const _____fpos64_t_defined : u32 = 1 ; pub const ____FILE_defined : u32 = 1 ; pub const __FILE_defined : u32 = 1 ; pub const __struct_FILE_defined : u32 = 1 ; pub const _IO_EOF_SEEN : u32 = 16 ; pub const _IO_ERR_SEEN : u32 = 32 ; pub const _IO_USER_LOCK : u32 = 32768 ; pub const __cookie_io_functions_t_defined : u32 = 1 ; pub const _IOFBF : u32 = 0 ; pub const _IOLBF : u32 = 1 ; pub const _IONBF : u32 = 2 ; pub const BUFSIZ : u32 = 8192 ; pub const EOF : i32 = - 1 ; pub const SEEK_SET : u32 = 0 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const P_tmpdir : & [u8 ; 5usize] = b"/tmp\0" ; pub const L_tmpnam : u32 = 20 ; pub const TMP_MAX : u32 = 238328 ; pub const _BITS_STDIO_LIM_H : u32 = 1 ; pub const FILENAME_MAX : u32 = 4096 ; pub const L_ctermid : u32 = 9 ; pub const FOPEN_MAX : u32 = 16 ; pub const _STRING_H : u32 = 1 ; pub const _BITS_TYPES_LOCALE_T_H : u32 = 1 ; pub const _BITS_TYPES___LOCALE_T_H : u32 = 1 ; pub const _STRINGS_H : u32 = 1 ; pub const YAJL_TREE_H : u32 = 1 ; pub const YAJL_MAX_DEPTH : u32 = 128 ; pub const YAJL_NUMBER_INT_VALID : u32 = 1 ; pub const YAJL_NUMBER_DOUBLE_VALID : u32 = 2 ; pub const OPT_PARSE_STRICT : u32 = 1 ; pub const OPT_GEN_KEY_VALUE : u32 = 2 ; pub const OPT_GEN_SIMPLIFY : u32 = 4 ; pub const OPT_PARSE_FULLKEY : u32 = 8 ; pub const OPT_GEN_NO_VALIDATE_UTF8 : u32 = 16 ; pub const _SYS_SYSLOG_H : u32 = 1 ; pub const _BITS_SYSLOG_PATH_H : u32 = 1 ; pub const _PATH_LOG : & [u8 ; 9usize] = b"/dev/log\0" ; pub const LOG_EMERG : u32 = 0 ; pub const LOG_ALERT : u32 = 1 ; pub const LOG_CRIT : u32 = 2 ; pub const LOG_ERR : u32 = 3 ; pub const LOG_WARNING : u32 = 4 ; pub const LOG_NOTICE : u32 = 5 ; pub const LOG_INFO : u32 = 6 ; pub const LOG_DEBUG : u32 = 7 ; pub const LOG_PRIMASK : u32 = 7 ; pub const LOG_KERN : u32 = 0 ; pub const LOG_USER : u32 = 8 ; pub const LOG_MAIL : u32 = 16 ; pub const LOG_DAEMON : u32 = 24 ; pub const LOG_AUTH : u32 = 32 ; pub const LOG_SYSLOG : u32 = 40 ; pub const LOG_LPR : u32 = 48 ; pub const LOG_NEWS : u32 = 56 ; pub const LOG_UUCP : u32 = 64 ; pub const LOG_CRON : u32 = 72 ; pub const LOG_AUTHPRIV : u32 = 80 ; pub const LOG_FTP : u32 = 88 ; pub const LOG_LOCAL0 : u32 = 128 ; pub const LOG_LOCAL1 : u32 = 136 ; pub const LOG_LOCAL2 : u32 = 144 ; pub const LOG_LOCAL3 : u32 = 152 ; pub const LOG_LOCAL4 : u32 = 160 ; pub const LOG_LOCAL5 : u32 = 168 ; pub const LOG_LOCAL6 : u32 = 176 ; pub const LOG_LOCAL7 : u32 = 184 ; pub const LOG_NFACILITIES : u32 = 24 ; pub const LOG_FACMASK : u32 = 1016 ; pub const LOG_PID : u32 = 1 ; pub const LOG_CONS : u32 = 2 ; pub const LOG_ODELAY : u32 = 4 ; pub const LOG_NDELAY : u32 = 8 ; pub const LOG_NOWAIT : u32 = 16 ; pub const LOG_PERROR : u32 = 32 ; pub const _UNISTD_H : u32 = 1 ; pub const _POSIX_VERSION : u32 = 200809 ; pub const __POSIX2_THIS_VERSION : u32 = 200809 ; pub const _POSIX2_VERSION : u32 = 200809 ; pub const _POSIX2_C_VERSION : u32 = 200809 ; pub const _POSIX2_C_BIND : u32 = 200809 ; pub const _POSIX2_C_DEV : u32 = 200809 ; pub const _POSIX2_SW_DEV : u32 = 200809 ; pub const _POSIX2_LOCALEDEF : u32 = 200809 ; pub const _XOPEN_VERSION : u32 = 700 ; pub const _XOPEN_XCU_VERSION : u32 = 4 ; pub const _XOPEN_XPG2 : u32 = 1 ; pub const _XOPEN_XPG3 : u32 = 1 ; pub const _XOPEN_XPG4 : u32 = 1 ; pub const _XOPEN_UNIX : u32 = 1 ; pub const _XOPEN_ENH_I18N : u32 = 1 ; pub const _XOPEN_LEGACY : u32 = 1 ; pub const _BITS_POSIX_OPT_H : u32 = 1 ; pub const _POSIX_JOB_CONTROL : u32 = 1 ; pub const _POSIX_SAVED_IDS : u32 = 1 ; pub const _POSIX_PRIORITY_SCHEDULING : u32 = 200809 ; pub const _POSIX_SYNCHRONIZED_IO : u32 = 200809 ; pub const _POSIX_FSYNC : u32 = 200809 ; pub const _POSIX_MAPPED_FILES : u32 = 200809 ; pub const _POSIX_MEMLOCK : u32 = 200809 ; pub const _POSIX_MEMLOCK_RANGE : u32 = 200809 ; pub const _POSIX_MEMORY_PROTECTION : u32 = 200809 ; pub const _POSIX_CHOWN_RESTRICTED : u32 = 0 ; pub const _POSIX_VDISABLE : u8 = 0u8 ; pub const _POSIX_NO_TRUNC : u32 = 1 ; pub const _XOPEN_REALTIME : u32 = 1 ; pub const _XOPEN_REALTIME_THREADS : u32 = 1 ; pub const _XOPEN_SHM : u32 = 1 ; pub const _POSIX_THREADS : u32 = 200809 ; pub const _POSIX_REENTRANT_FUNCTIONS : u32 = 1 ; pub const _POSIX_THREAD_SAFE_FUNCTIONS : u32 = 200809 ; pub const _POSIX_THREAD_PRIORITY_SCHEDULING : u32 = 200809 ; pub const _POSIX_THREAD_ATTR_STACKSIZE : u32 = 200809 ; pub const _POSIX_THREAD_ATTR_STACKADDR : u32 = 200809 ; pub const _POSIX_THREAD_PRIO_INHERIT : u32 = 200809 ; pub const _POSIX_THREAD_PRIO_PROTECT : u32 = 200809 ; pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT : u32 = 200809 ; pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT : i32 = - 1 ; pub const _POSIX_SEMAPHORES : u32 = 200809 ; pub const _POSIX_REALTIME_SIGNALS : u32 = 200809 ; pub const _POSIX_ASYNCHRONOUS_IO : u32 = 200809 ; pub const _POSIX_ASYNC_IO : u32 = 1 ; pub const _LFS_ASYNCHRONOUS_IO : u32 = 1 ; pub const _POSIX_PRIORITIZED_IO : u32 = 200809 ; pub const _LFS64_ASYNCHRONOUS_IO : u32 = 1 ; pub const _LFS_LARGEFILE : u32 = 1 ; pub const _LFS64_LARGEFILE : u32 = 1 ; pub const _LFS64_STDIO : u32 = 1 ; pub const _POSIX_SHARED_MEMORY_OBJECTS : u32 = 200809 ; pub const _POSIX_CPUTIME : u32 = 0 ; pub const _POSIX_THREAD_CPUTIME : u32 = 0 ; pub const _POSIX_REGEXP : u32 = 1 ; pub const _POSIX_READER_WRITER_LOCKS : u32 = 200809 ; pub const _POSIX_SHELL : u32 = 1 ; pub const _POSIX_TIMEOUTS : u32 = 200809 ; pub const _POSIX_SPIN_LOCKS : u32 = 200809 ; pub const _POSIX_SPAWN : u32 = 200809 ; pub const _POSIX_TIMERS : u32 = 200809 ; pub const _POSIX_BARRIERS : u32 = 200809 ; pub const _POSIX_MESSAGE_PASSING : u32 = 200809 ; pub const _POSIX_THREAD_PROCESS_SHARED : u32 = 200809 ; pub const _POSIX_MONOTONIC_CLOCK : u32 = 0 ; pub const _POSIX_CLOCK_SELECTION : u32 = 200809 ; pub const _POSIX_ADVISORY_INFO : u32 = 200809 ; pub const _POSIX_IPV6 : u32 = 200809 ; pub const _POSIX_RAW_SOCKETS : u32 = 200809 ; pub const _POSIX2_CHAR_TERM : u32 = 200809 ; pub const _POSIX_SPORADIC_SERVER : i32 = - 1 ; pub const _POSIX_THREAD_SPORADIC_SERVER : i32 = - 1 ; pub const _POSIX_TRACE : i32 = - 1 ; pub const _POSIX_TRACE_EVENT_FILTER : i32 = - 1 ; pub const _POSIX_TRACE_INHERIT : i32 = - 1 ; pub const _POSIX_TRACE_LOG : i32 = - 1 ; pub const _POSIX_TYPED_MEMORY_OBJECTS : i32 = - 1 ; pub const _POSIX_V7_LPBIG_OFFBIG : i32 = - 1 ; pub const _POSIX_V6_LPBIG_OFFBIG : i32 = - 1 ; pub const _XBS5_LPBIG_OFFBIG : i32 = - 1 ; pub const _POSIX_V7_LP64_OFF64 : u32 = 1 ; pub const _POSIX_V6_LP64_OFF64 : u32 = 1 ; pub const _XBS5_LP64_OFF64 : u32 = 1 ; pub const __ILP32_OFF32_CFLAGS : & [u8 ; 5usize] = b"-m32\0" ; pub const __ILP32_OFF32_LDFLAGS : & [u8 ; 5usize] = b"-m32\0" ; pub const __ILP32_OFFBIG_CFLAGS : & [u8 ; 48usize] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0" ; pub const __ILP32_OFFBIG_LDFLAGS : & [u8 ; 5usize] = b"-m32\0" ; pub const __LP64_OFF64_CFLAGS : & [u8 ; 5usize] = b"-m64\0" ; pub const __LP64_OFF64_LDFLAGS : & [u8 ; 5usize] = b"-m64\0" ; pub const STDIN_FILENO : u32 = 0 ; pub const STDOUT_FILENO : u32 = 1 ; pub const STDERR_FILENO : u32 = 2 ; pub const R_OK : u32 = 4 ; pub const W_OK : u32 = 2 ; pub const X_OK : u32 = 1 ; pub const F_OK : u32 = 0 ; pub const L_SET : u32 = 0 ; pub const L_INCR : u32 = 1 ; pub const L_XTND : u32 = 2 ; pub const _GETOPT_POSIX_H : u32 = 1 ; pub const _GETOPT_CORE_H : u32 = 1 ; pub const F_ULOCK : u32 = 0 ; pub const F_LOCK : u32 = 1 ; pub const F_TLOCK : u32 = 2 ; pub const F_TEST : u32 = 3 ; pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __int_least8_t = __int8_t ; pub type __uint_least8_t = __uint8_t ; pub type __int_least16_t = __int16_t ; pub type __uint_least16_t = __uint16_t ; pub type __int_least32_t = __int32_t ; pub type __uint_least32_t = __uint32_t ; pub type __int_least64_t = __int64_t ; pub type __uint_least64_t = __uint64_t ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __intmax_t = :: std :: os :: raw :: c_long ; pub type __uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __fsid_t { pub __val : [:: std :: os :: raw :: c_int ; 2usize] , } # [test] fn bindgen_test_layout___fsid_t () { const UNINIT : :: std :: mem :: MaybeUninit < __fsid_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __fsid_t > () , 8usize , concat ! ("Size of: " , stringify ! (__fsid_t))) ; assert_eq ! (:: std :: mem :: align_of :: < __fsid_t > () , 4usize , concat ! ("Alignment of " , stringify ! (__fsid_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __val) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__fsid_t) , "::" , stringify ! (__val))) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __suseconds64_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type off_t = __off_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type clockid_t = __clockid_t ; pub type time_t = __time_t ; pub type timer_t = __timer_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = __uint8_t ; pub type u_int16_t = __uint16_t ; pub type u_int32_t = __uint32_t ; pub type u_int64_t = __uint64_t ; pub type register_t = :: std :: os :: raw :: c_long ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __sigset_t { pub __val : [:: std :: os :: raw :: c_ulong ; 16usize] , } # [test] fn bindgen_test_layout___sigset_t () { const UNINIT : :: std :: mem :: MaybeUninit < __sigset_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __sigset_t > () , 128usize , concat ! ("Size of: " , stringify ! (__sigset_t))) ; assert_eq ! (:: std :: mem :: align_of :: < __sigset_t > () , 8usize , concat ! ("Alignment of " , stringify ! (__sigset_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __val) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__sigset_t) , "::" , stringify ! (__val))) ; } pub type sigset_t = __sigset_t ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [test] fn bindgen_test_layout_timeval () { const UNINIT : :: std :: mem :: MaybeUninit < timeval > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < timeval > () , 16usize , concat ! ("Size of: " , stringify ! (timeval))) ; assert_eq ! (:: std :: mem :: align_of :: < timeval > () , 8usize , concat ! ("Alignment of " , stringify ! (timeval))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . tv_sec) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (timeval) , "::" , stringify ! (tv_sec))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . tv_usec) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (timeval) , "::" , stringify ! (tv_usec))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [test] fn bindgen_test_layout_timespec () { const UNINIT : :: std :: mem :: MaybeUninit < timespec > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < timespec > () , 16usize , concat ! ("Size of: " , stringify ! (timespec))) ; assert_eq ! (:: std :: mem :: align_of :: < timespec > () , 8usize , concat ! ("Alignment of " , stringify ! (timespec))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . tv_sec) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (timespec) , "::" , stringify ! (tv_sec))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . tv_nsec) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (timespec) , "::" , stringify ! (tv_nsec))) ; } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct fd_set { pub __fds_bits : [__fd_mask ; 16usize] , } # [test] fn bindgen_test_layout_fd_set () { const UNINIT : :: std :: mem :: MaybeUninit < fd_set > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < fd_set > () , 128usize , concat ! ("Size of: " , stringify ! (fd_set))) ; assert_eq ! (:: std :: mem :: align_of :: < fd_set > () , 8usize , concat ! ("Alignment of " , stringify ! (fd_set))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __fds_bits) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (fd_set) , "::" , stringify ! (__fds_bits))) ; } pub type fd_mask = __fd_mask ; extern "C" { pub fn select (__nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pselect (__nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t) -> :: std :: os :: raw :: c_int ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; # [repr (C)] # [derive (Copy , Clone)] pub union __atomic_wide_counter { pub __value64 : :: std :: os :: raw :: c_ulonglong , pub __value32 : __atomic_wide_counter__bindgen_ty_1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __atomic_wide_counter__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [test] fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1 () { const UNINIT : :: std :: mem :: MaybeUninit < __atomic_wide_counter__bindgen_ty_1 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __atomic_wide_counter__bindgen_ty_1 > () , 8usize , concat ! ("Size of: " , stringify ! (__atomic_wide_counter__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: < __atomic_wide_counter__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (__atomic_wide_counter__bindgen_ty_1))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __low) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__atomic_wide_counter__bindgen_ty_1) , "::" , stringify ! (__low))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __high) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (__atomic_wide_counter__bindgen_ty_1) , "::" , stringify ! (__high))) ; } # [test] fn bindgen_test_layout___atomic_wide_counter () { const UNINIT : :: std :: mem :: MaybeUninit < __atomic_wide_counter > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __atomic_wide_counter > () , 8usize , concat ! ("Size of: " , stringify ! (__atomic_wide_counter))) ; assert_eq ! (:: std :: mem :: align_of :: < __atomic_wide_counter > () , 8usize , concat ! ("Alignment of " , stringify ! (__atomic_wide_counter))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __value64) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__atomic_wide_counter) , "::" , stringify ! (__value64))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __value32) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__atomic_wide_counter) , "::" , stringify ! (__value32))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [test] fn bindgen_test_layout___pthread_internal_list () { const UNINIT : :: std :: mem :: MaybeUninit < __pthread_internal_list > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __pthread_internal_list > () , 16usize , concat ! ("Size of: " , stringify ! (__pthread_internal_list))) ; assert_eq ! (:: std :: mem :: align_of :: < __pthread_internal_list > () , 8usize , concat ! ("Alignment of " , stringify ! (__pthread_internal_list))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __prev) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__pthread_internal_list) , "::" , stringify ! (__prev))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __next) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__pthread_internal_list) , "::" , stringify ! (__next))) ; } pub type __pthread_list_t = __pthread_internal_list ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_internal_slist { pub __next : * mut __pthread_internal_slist , } # [test] fn bindgen_test_layout___pthread_internal_slist () { const UNINIT : :: std :: mem :: MaybeUninit < __pthread_internal_slist > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __pthread_internal_slist > () , 8usize , concat ! ("Size of: " , stringify ! (__pthread_internal_slist))) ; assert_eq ! (:: std :: mem :: align_of :: < __pthread_internal_slist > () , 8usize , concat ! ("Alignment of " , stringify ! (__pthread_internal_slist))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __next) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__pthread_internal_slist) , "::" , stringify ! (__next))) ; } pub type __pthread_slist_t = __pthread_internal_slist ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [test] fn bindgen_test_layout___pthread_mutex_s () { const UNINIT : :: std :: mem :: MaybeUninit < __pthread_mutex_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __pthread_mutex_s > () , 40usize , concat ! ("Size of: " , stringify ! (__pthread_mutex_s))) ; assert_eq ! (:: std :: mem :: align_of :: < __pthread_mutex_s > () , 8usize , concat ! ("Alignment of " , stringify ! (__pthread_mutex_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __lock) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__lock))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __count) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__count))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __owner) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__owner))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __nusers) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__nusers))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __kind) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__kind))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __spins) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__spins))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __elision) as usize - ptr as usize } , 22usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__elision))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __list) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (__pthread_mutex_s) , "::" , stringify ! (__list))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __pthread_rwlock_arch_t { pub __readers : :: std :: os :: raw :: c_uint , pub __writers : :: std :: os :: raw :: c_uint , pub __wrphase_futex : :: std :: os :: raw :: c_uint , pub __writers_futex : :: std :: os :: raw :: c_uint , pub __pad3 : :: std :: os :: raw :: c_uint , pub __pad4 : :: std :: os :: raw :: c_uint , pub __cur_writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [:: std :: os :: raw :: c_uchar ; 7usize] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [test] fn bindgen_test_layout___pthread_rwlock_arch_t () { const UNINIT : :: std :: mem :: MaybeUninit < __pthread_rwlock_arch_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __pthread_rwlock_arch_t > () , 56usize , concat ! ("Size of: " , stringify ! (__pthread_rwlock_arch_t))) ; assert_eq ! (:: std :: mem :: align_of :: < __pthread_rwlock_arch_t > () , 8usize , concat ! ("Alignment of " , stringify ! (__pthread_rwlock_arch_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __readers) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__readers))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __writers) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__writers))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __wrphase_futex) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__wrphase_futex))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __writers_futex) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__writers_futex))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __pad3) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__pad3))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __pad4) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__pad4))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __cur_writer) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__cur_writer))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __shared) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__shared))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __rwelision) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__rwelision))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __pad1) as usize - ptr as usize } , 33usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__pad1))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __pad2) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__pad2))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __flags) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (__pthread_rwlock_arch_t) , "::" , stringify ! (__flags))) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct __pthread_cond_s { pub __wseq : __atomic_wide_counter , pub __g1_start : __atomic_wide_counter , pub __g_refs : [:: std :: os :: raw :: c_uint ; 2usize] , pub __g_size : [:: std :: os :: raw :: c_uint ; 2usize] , pub __g1_orig_size : :: std :: os :: raw :: c_uint , pub __wrefs : :: std :: os :: raw :: c_uint , pub __g_signals : [:: std :: os :: raw :: c_uint ; 2usize] , } # [test] fn bindgen_test_layout___pthread_cond_s () { const UNINIT : :: std :: mem :: MaybeUninit < __pthread_cond_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __pthread_cond_s > () , 48usize , concat ! ("Size of: " , stringify ! (__pthread_cond_s))) ; assert_eq ! (:: std :: mem :: align_of :: < __pthread_cond_s > () , 8usize , concat ! ("Alignment of " , stringify ! (__pthread_cond_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __wseq) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__pthread_cond_s) , "::" , stringify ! (__wseq))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __g1_start) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__pthread_cond_s) , "::" , stringify ! (__g1_start))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __g_refs) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (__pthread_cond_s) , "::" , stringify ! (__g_refs))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __g_size) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (__pthread_cond_s) , "::" , stringify ! (__g_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __g1_orig_size) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (__pthread_cond_s) , "::" , stringify ! (__g1_orig_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __wrefs) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (__pthread_cond_s) , "::" , stringify ! (__wrefs))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __g_signals) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (__pthread_cond_s) , "::" , stringify ! (__g_signals))) ; } pub type __tss_t = :: std :: os :: raw :: c_uint ; pub type __thrd_t = :: std :: os :: raw :: c_ulong ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __once_flag { pub __data : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout___once_flag () { const UNINIT : :: std :: mem :: MaybeUninit < __once_flag > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __once_flag > () , 4usize , concat ! ("Size of: " , stringify ! (__once_flag))) ; assert_eq ! (:: std :: mem :: align_of :: < __once_flag > () , 4usize , concat ! ("Alignment of " , stringify ! (__once_flag))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __data) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__once_flag) , "::" , stringify ! (__data))) ; } pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_mutexattr_t { pub __size : [:: std :: os :: raw :: c_char ; 4usize] , pub __align : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_pthread_mutexattr_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_mutexattr_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_mutexattr_t > () , 4usize , concat ! ("Size of: " , stringify ! (pthread_mutexattr_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_mutexattr_t > () , 4usize , concat ! ("Alignment of " , stringify ! (pthread_mutexattr_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_mutexattr_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_mutexattr_t) , "::" , stringify ! (__align))) ; } # [repr (C)] # [derive (Copy , Clone)] pub union pthread_condattr_t { pub __size : [:: std :: os :: raw :: c_char ; 4usize] , pub __align : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_pthread_condattr_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_condattr_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_condattr_t > () , 4usize , concat ! ("Size of: " , stringify ! (pthread_condattr_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_condattr_t > () , 4usize , concat ! ("Alignment of " , stringify ! (pthread_condattr_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_condattr_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_condattr_t) , "::" , stringify ! (__align))) ; } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_attr_t { pub __size : [:: std :: os :: raw :: c_char ; 56usize] , pub __align : :: std :: os :: raw :: c_long , } # [test] fn bindgen_test_layout_pthread_attr_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_attr_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_attr_t > () , 56usize , concat ! ("Size of: " , stringify ! (pthread_attr_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_attr_t > () , 8usize , concat ! ("Alignment of " , stringify ! (pthread_attr_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_attr_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_attr_t) , "::" , stringify ! (__align))) ; } # [repr (C)] # [derive (Copy , Clone)] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [:: std :: os :: raw :: c_char ; 40usize] , pub __align : :: std :: os :: raw :: c_long , } # [test] fn bindgen_test_layout_pthread_mutex_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_mutex_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_mutex_t > () , 40usize , concat ! ("Size of: " , stringify ! (pthread_mutex_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_mutex_t > () , 8usize , concat ! ("Alignment of " , stringify ! (pthread_mutex_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __data) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_mutex_t) , "::" , stringify ! (__data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_mutex_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_mutex_t) , "::" , stringify ! (__align))) ; } # [repr (C)] # [derive (Copy , Clone)] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [:: std :: os :: raw :: c_char ; 48usize] , pub __align : :: std :: os :: raw :: c_longlong , } # [test] fn bindgen_test_layout_pthread_cond_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_cond_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_cond_t > () , 48usize , concat ! ("Size of: " , stringify ! (pthread_cond_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_cond_t > () , 8usize , concat ! ("Alignment of " , stringify ! (pthread_cond_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __data) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_cond_t) , "::" , stringify ! (__data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_cond_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_cond_t) , "::" , stringify ! (__align))) ; } # [repr (C)] # [derive (Copy , Clone)] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [:: std :: os :: raw :: c_char ; 56usize] , pub __align : :: std :: os :: raw :: c_long , } # [test] fn bindgen_test_layout_pthread_rwlock_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_rwlock_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_rwlock_t > () , 56usize , concat ! ("Size of: " , stringify ! (pthread_rwlock_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_rwlock_t > () , 8usize , concat ! ("Alignment of " , stringify ! (pthread_rwlock_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __data) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_rwlock_t) , "::" , stringify ! (__data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_rwlock_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_rwlock_t) , "::" , stringify ! (__align))) ; } # [repr (C)] # [derive (Copy , Clone)] pub union pthread_rwlockattr_t { pub __size : [:: std :: os :: raw :: c_char ; 8usize] , pub __align : :: std :: os :: raw :: c_long , } # [test] fn bindgen_test_layout_pthread_rwlockattr_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_rwlockattr_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_rwlockattr_t > () , 8usize , concat ! ("Size of: " , stringify ! (pthread_rwlockattr_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_rwlockattr_t > () , 8usize , concat ! ("Alignment of " , stringify ! (pthread_rwlockattr_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_rwlockattr_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_rwlockattr_t) , "::" , stringify ! (__align))) ; } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Copy , Clone)] pub union pthread_barrier_t { pub __size : [:: std :: os :: raw :: c_char ; 32usize] , pub __align : :: std :: os :: raw :: c_long , } # [test] fn bindgen_test_layout_pthread_barrier_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_barrier_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_barrier_t > () , 32usize , concat ! ("Size of: " , stringify ! (pthread_barrier_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_barrier_t > () , 8usize , concat ! ("Alignment of " , stringify ! (pthread_barrier_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_barrier_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_barrier_t) , "::" , stringify ! (__align))) ; } # [repr (C)] # [derive (Copy , Clone)] pub union pthread_barrierattr_t { pub __size : [:: std :: os :: raw :: c_char ; 4usize] , pub __align : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_pthread_barrierattr_t () { const UNINIT : :: std :: mem :: MaybeUninit < pthread_barrierattr_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < pthread_barrierattr_t > () , 4usize , concat ! ("Size of: " , stringify ! (pthread_barrierattr_t))) ; assert_eq ! (:: std :: mem :: align_of :: < pthread_barrierattr_t > () , 4usize , concat ! ("Alignment of " , stringify ! (pthread_barrierattr_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_barrierattr_t) , "::" , stringify ! (__size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __align) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pthread_barrierattr_t) , "::" , stringify ! (__align))) ; } pub type int_least8_t = __int_least8_t ; pub type int_least16_t = __int_least16_t ; pub type int_least32_t = __int_least32_t ; pub type int_least64_t = __int_least64_t ; pub type uint_least8_t = __uint_least8_t ; pub type uint_least16_t = __uint_least16_t ; pub type uint_least32_t = __uint_least32_t ; pub type uint_least64_t = __uint_least64_t ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; pub type wchar_t = :: std :: os :: raw :: c_int ; pub type _Float32 = f32 ; pub type _Float64 = f64 ; pub type _Float32x = f64 ; pub type _Float64x = u128 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_div_t () { const UNINIT : :: std :: mem :: MaybeUninit < div_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < div_t > () , 8usize , concat ! ("Size of: " , stringify ! (div_t))) ; assert_eq ! (:: std :: mem :: align_of :: < div_t > () , 4usize , concat ! ("Alignment of " , stringify ! (div_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . quot) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (div_t) , "::" , stringify ! (quot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rem) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (div_t) , "::" , stringify ! (rem))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [test] fn bindgen_test_layout_ldiv_t () { const UNINIT : :: std :: mem :: MaybeUninit < ldiv_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < ldiv_t > () , 16usize , concat ! ("Size of: " , stringify ! (ldiv_t))) ; assert_eq ! (:: std :: mem :: align_of :: < ldiv_t > () , 8usize , concat ! ("Alignment of " , stringify ! (ldiv_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . quot) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ldiv_t) , "::" , stringify ! (quot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rem) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ldiv_t) , "::" , stringify ! (rem))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [test] fn bindgen_test_layout_lldiv_t () { const UNINIT : :: std :: mem :: MaybeUninit < lldiv_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < lldiv_t > () , 16usize , concat ! ("Size of: " , stringify ! (lldiv_t))) ; assert_eq ! (:: std :: mem :: align_of :: < lldiv_t > () , 8usize , concat ! ("Alignment of " , stringify ! (lldiv_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . quot) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (lldiv_t) , "::" , stringify ! (quot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rem) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (lldiv_t) , "::" , stringify ! (rem))) ; } extern "C" { pub fn __ctype_get_mb_cur_max () -> usize ; } extern "C" { pub fn atof (__nptr : * const :: std :: os :: raw :: c_char) -> f64 ; } extern "C" { pub fn atoi (__nptr : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn atol (__nptr : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn atoll (__nptr : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn strtod (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char) -> f64 ; } extern "C" { pub fn strtof (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char) -> f32 ; } extern "C" { pub fn strtold (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char) -> u128 ; } extern "C" { pub fn strtol (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn strtoul (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strtoq (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn strtouq (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn strtoll (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn strtoull (__nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn l64a (__n : :: std :: os :: raw :: c_long) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn a64l (__s : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn random () -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn srandom (__seed : :: std :: os :: raw :: c_uint) ; } extern "C" { pub fn initstate (__seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn setstate (__statebuf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : :: std :: os :: raw :: c_int , pub rand_deg : :: std :: os :: raw :: c_int , pub rand_sep : :: std :: os :: raw :: c_int , pub end_ptr : * mut i32 , } # [test] fn bindgen_test_layout_random_data () { const UNINIT : :: std :: mem :: MaybeUninit < random_data > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < random_data > () , 48usize , concat ! ("Size of: " , stringify ! (random_data))) ; assert_eq ! (:: std :: mem :: align_of :: < random_data > () , 8usize , concat ! ("Alignment of " , stringify ! (random_data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . fptr) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (random_data) , "::" , stringify ! (fptr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rptr) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (random_data) , "::" , stringify ! (rptr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (random_data) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rand_type) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (random_data) , "::" , stringify ! (rand_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rand_deg) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (random_data) , "::" , stringify ! (rand_deg))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rand_sep) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (random_data) , "::" , stringify ! (rand_sep))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . end_ptr) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (random_data) , "::" , stringify ! (end_ptr))) ; } extern "C" { pub fn random_r (__buf : * mut random_data , __result : * mut i32) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn srandom_r (__seed : :: std :: os :: raw :: c_uint , __buf : * mut random_data) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn initstate_r (__seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , __buf : * mut random_data) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setstate_r (__statebuf : * mut :: std :: os :: raw :: c_char , __buf : * mut random_data) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rand () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn srand (__seed : :: std :: os :: raw :: c_uint) ; } extern "C" { pub fn rand_r (__seed : * mut :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn drand48 () -> f64 ; } extern "C" { pub fn erand48 (__xsubi : * mut :: std :: os :: raw :: c_ushort) -> f64 ; } extern "C" { pub fn lrand48 () -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn nrand48 (__xsubi : * mut :: std :: os :: raw :: c_ushort) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn mrand48 () -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn jrand48 (__xsubi : * mut :: std :: os :: raw :: c_ushort) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn srand48 (__seedval : :: std :: os :: raw :: c_long) ; } extern "C" { pub fn seed48 (__seed16v : * mut :: std :: os :: raw :: c_ushort) -> * mut :: std :: os :: raw :: c_ushort ; } extern "C" { pub fn lcong48 (__param : * mut :: std :: os :: raw :: c_ushort) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct drand48_data { pub __x : [:: std :: os :: raw :: c_ushort ; 3usize] , pub __old_x : [:: std :: os :: raw :: c_ushort ; 3usize] , pub __c : :: std :: os :: raw :: c_ushort , pub __init : :: std :: os :: raw :: c_ushort , pub __a : :: std :: os :: raw :: c_ulonglong , } # [test] fn bindgen_test_layout_drand48_data () { const UNINIT : :: std :: mem :: MaybeUninit < drand48_data > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < drand48_data > () , 24usize , concat ! ("Size of: " , stringify ! (drand48_data))) ; assert_eq ! (:: std :: mem :: align_of :: < drand48_data > () , 8usize , concat ! ("Alignment of " , stringify ! (drand48_data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __x) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (drand48_data) , "::" , stringify ! (__x))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __old_x) as usize - ptr as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (drand48_data) , "::" , stringify ! (__old_x))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __c) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (drand48_data) , "::" , stringify ! (__c))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __init) as usize - ptr as usize } , 14usize , concat ! ("Offset of field: " , stringify ! (drand48_data) , "::" , stringify ! (__init))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __a) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (drand48_data) , "::" , stringify ! (__a))) ; } extern "C" { pub fn drand48_r (__buffer : * mut drand48_data , __result : * mut f64) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn erand48_r (__xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lrand48_r (__buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn nrand48_r (__xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mrand48_r (__buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn jrand48_r (__xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn srand48_r (__seedval : :: std :: os :: raw :: c_long , __buffer : * mut drand48_data) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn seed48_r (__seed16v : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lcong48_r (__param : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn arc4random () -> __uint32_t ; } extern "C" { pub fn arc4random_buf (__buf : * mut :: std :: os :: raw :: c_void , __size : usize) ; } extern "C" { pub fn arc4random_uniform (__upper_bound : __uint32_t) -> __uint32_t ; } extern "C" { pub fn malloc (__size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn calloc (__nmemb : :: std :: os :: raw :: c_ulong , __size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn realloc (__ptr : * mut :: std :: os :: raw :: c_void , __size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn free (__ptr : * mut :: std :: os :: raw :: c_void) ; } extern "C" { pub fn reallocarray (__ptr : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn alloca (__size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn valloc (__size : usize) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn posix_memalign (__memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn aligned_alloc (__alignment : :: std :: os :: raw :: c_ulong , __size : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn abort () -> ! ; } extern "C" { pub fn atexit (__func : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn at_quick_exit (__func : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn on_exit (__func : :: std :: option :: Option < unsafe extern "C" fn (__status : :: std :: os :: raw :: c_int , __arg : * mut :: std :: os :: raw :: c_void) > , __arg : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn exit (__status : :: std :: os :: raw :: c_int) -> ! ; } extern "C" { pub fn quick_exit (__status : :: std :: os :: raw :: c_int) -> ! ; } extern "C" { pub fn _Exit (__status : :: std :: os :: raw :: c_int) -> ! ; } extern "C" { pub fn getenv (__name : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn putenv (__string : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setenv (__name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __replace : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn unsetenv (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearenv () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mktemp (__template : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn mkstemp (__template : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mkstemps (__template : * mut :: std :: os :: raw :: c_char , __suffixlen : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mkdtemp (__template : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn system (__command : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn realpath (__name : * const :: std :: os :: raw :: c_char , __resolved : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > ; extern "C" { pub fn bsearch (__key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn qsort (__base : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t) ; } extern "C" { pub fn abs (__x : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn labs (__x : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn llabs (__x : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn div (__numer : :: std :: os :: raw :: c_int , __denom : :: std :: os :: raw :: c_int) -> div_t ; } extern "C" { pub fn ldiv (__numer : :: std :: os :: raw :: c_long , __denom : :: std :: os :: raw :: c_long) -> ldiv_t ; } extern "C" { pub fn lldiv (__numer : :: std :: os :: raw :: c_longlong , __denom : :: std :: os :: raw :: c_longlong) -> lldiv_t ; } extern "C" { pub fn ecvt (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fcvt (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn gcvt (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn qecvt (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn qfcvt (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn qgcvt (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ecvt_r (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fcvt_r (__value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn qecvt_r (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn qfcvt_r (__value : u128 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mblen (__s : * const :: std :: os :: raw :: c_char , __n : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mbtowc (__pwc : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wctomb (__s : * mut :: std :: os :: raw :: c_char , __wchar : wchar_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mbstowcs (__pwcs : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize) -> usize ; } extern "C" { pub fn wcstombs (__s : * mut :: std :: os :: raw :: c_char , __pwcs : * const wchar_t , __n : usize) -> usize ; } extern "C" { pub fn rpmatch (__response : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getsubopt (__optionp : * mut * mut :: std :: os :: raw :: c_char , __tokens : * const * mut :: std :: os :: raw :: c_char , __valuep : * mut * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getloadavg (__loadavg : * mut f64 , __nelem : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } pub type __gnuc_va_list = __builtin_va_list ; # [repr (C)] # [derive (Copy , Clone)] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [:: std :: os :: raw :: c_char ; 4usize] , } # [test] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 () { const UNINIT : :: std :: mem :: MaybeUninit < __mbstate_t__bindgen_ty_1 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > () , 4usize , concat ! ("Size of: " , stringify ! (__mbstate_t__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (__mbstate_t__bindgen_ty_1))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __wch) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__mbstate_t__bindgen_ty_1) , "::" , stringify ! (__wch))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __wchb) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__mbstate_t__bindgen_ty_1) , "::" , stringify ! (__wchb))) ; } # [test] fn bindgen_test_layout___mbstate_t () { const UNINIT : :: std :: mem :: MaybeUninit < __mbstate_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __mbstate_t > () , 8usize , concat ! ("Size of: " , stringify ! (__mbstate_t))) ; assert_eq ! (:: std :: mem :: align_of :: < __mbstate_t > () , 4usize , concat ! ("Alignment of " , stringify ! (__mbstate_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __count) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__mbstate_t) , "::" , stringify ! (__count))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __value) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (__mbstate_t) , "::" , stringify ! (__value))) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } # [test] fn bindgen_test_layout__G_fpos_t () { const UNINIT : :: std :: mem :: MaybeUninit < _G_fpos_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _G_fpos_t > () , 16usize , concat ! ("Size of: " , stringify ! (_G_fpos_t))) ; assert_eq ! (:: std :: mem :: align_of :: < _G_fpos_t > () , 8usize , concat ! ("Alignment of " , stringify ! (_G_fpos_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __pos) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_G_fpos_t) , "::" , stringify ! (__pos))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __state) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (_G_fpos_t) , "::" , stringify ! (__state))) ; } pub type __fpos_t = _G_fpos_t ; # [repr (C)] # [derive (Copy , Clone)] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } # [test] fn bindgen_test_layout__G_fpos64_t () { const UNINIT : :: std :: mem :: MaybeUninit < _G_fpos64_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _G_fpos64_t > () , 16usize , concat ! ("Size of: " , stringify ! (_G_fpos64_t))) ; assert_eq ! (:: std :: mem :: align_of :: < _G_fpos64_t > () , 8usize , concat ! ("Alignment of " , stringify ! (_G_fpos64_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __pos) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_G_fpos64_t) , "::" , stringify ! (__pos))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __state) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (_G_fpos64_t) , "::" , stringify ! (__state))) ; } pub type __fpos64_t = _G_fpos64_t ; pub type __FILE = _IO_FILE ; pub type FILE = _IO_FILE ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_marker { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_codecvt { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_wide_data { _unused : [u8 ; 0] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [:: std :: os :: raw :: c_char ; 1usize] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub _codecvt : * mut _IO_codecvt , pub _wide_data : * mut _IO_wide_data , pub _freeres_list : * mut _IO_FILE , pub _freeres_buf : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [:: std :: os :: raw :: c_char ; 20usize] , } # [test] fn bindgen_test_layout__IO_FILE () { const UNINIT : :: std :: mem :: MaybeUninit < _IO_FILE > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _IO_FILE > () , 216usize , concat ! ("Size of: " , stringify ! (_IO_FILE))) ; assert_eq ! (:: std :: mem :: align_of :: < _IO_FILE > () , 8usize , concat ! ("Alignment of " , stringify ! (_IO_FILE))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _flags) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_flags))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_read_ptr) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_read_ptr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_read_end) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_read_end))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_read_base) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_read_base))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_write_base) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_write_base))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_write_ptr) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_write_ptr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_write_end) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_write_end))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_buf_base) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_buf_base))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_buf_end) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_buf_end))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_save_base) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_save_base))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_backup_base) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_backup_base))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _IO_save_end) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_save_end))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _markers) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_markers))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _chain) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_chain))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _fileno) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_fileno))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _flags2) as usize - ptr as usize } , 116usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_flags2))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _old_offset) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_old_offset))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _cur_column) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_cur_column))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _vtable_offset) as usize - ptr as usize } , 130usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_vtable_offset))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _shortbuf) as usize - ptr as usize } , 131usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_shortbuf))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _lock) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_lock))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _offset) as usize - ptr as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_offset))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _codecvt) as usize - ptr as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_codecvt))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _wide_data) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_wide_data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _freeres_list) as usize - ptr as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_freeres_list))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _freeres_buf) as usize - ptr as usize } , 176usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_freeres_buf))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __pad5) as usize - ptr as usize } , 184usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (__pad5))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _mode) as usize - ptr as usize } , 192usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_mode))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _unused2) as usize - ptr as usize } , 196usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_unused2))) ; } pub type cookie_read_function_t = :: std :: option :: Option < unsafe extern "C" fn (__cookie : * mut :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize) -> __ssize_t > ; pub type cookie_write_function_t = :: std :: option :: Option < unsafe extern "C" fn (__cookie : * mut :: std :: os :: raw :: c_void , __buf : * const :: std :: os :: raw :: c_char , __nbytes : usize) -> __ssize_t > ; pub type cookie_seek_function_t = :: std :: option :: Option < unsafe extern "C" fn (__cookie : * mut :: std :: os :: raw :: c_void , __pos : * mut __off64_t , __w : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int > ; pub type cookie_close_function_t = :: std :: option :: Option < unsafe extern "C" fn (__cookie : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_cookie_io_functions_t { pub read : cookie_read_function_t , pub write : cookie_write_function_t , pub seek : cookie_seek_function_t , pub close : cookie_close_function_t , } # [test] fn bindgen_test_layout__IO_cookie_io_functions_t () { const UNINIT : :: std :: mem :: MaybeUninit < _IO_cookie_io_functions_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _IO_cookie_io_functions_t > () , 32usize , concat ! ("Size of: " , stringify ! (_IO_cookie_io_functions_t))) ; assert_eq ! (:: std :: mem :: align_of :: < _IO_cookie_io_functions_t > () , 8usize , concat ! ("Alignment of " , stringify ! (_IO_cookie_io_functions_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . read) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_IO_cookie_io_functions_t) , "::" , stringify ! (read))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . write) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (_IO_cookie_io_functions_t) , "::" , stringify ! (write))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . seek) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (_IO_cookie_io_functions_t) , "::" , stringify ! (seek))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . close) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (_IO_cookie_io_functions_t) , "::" , stringify ! (close))) ; } pub type cookie_io_functions_t = _IO_cookie_io_functions_t ; pub type va_list = __gnuc_va_list ; pub type fpos_t = __fpos_t ; extern "C" { pub static mut stdin : * mut FILE ; } extern "C" { pub static mut stdout : * mut FILE ; } extern "C" { pub static mut stderr : * mut FILE ; } extern "C" { pub fn remove (__filename : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rename (__old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn renameat (__oldfd : :: std :: os :: raw :: c_int , __old : * const :: std :: os :: raw :: c_char , __newfd : :: std :: os :: raw :: c_int , __new : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fclose (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tmpfile () -> * mut FILE ; } extern "C" { pub fn tmpnam (arg1 : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tmpnam_r (__s : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tempnam (__dir : * const :: std :: os :: raw :: c_char , __pfx : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fflush (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush_unlocked (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fopen (__filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char) -> * mut FILE ; } extern "C" { pub fn freopen (__filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE) -> * mut FILE ; } extern "C" { pub fn fdopen (__fd : :: std :: os :: raw :: c_int , __modes : * const :: std :: os :: raw :: c_char) -> * mut FILE ; } extern "C" { pub fn fopencookie (__magic_cookie : * mut :: std :: os :: raw :: c_void , __modes : * const :: std :: os :: raw :: c_char , __io_funcs : cookie_io_functions_t) -> * mut FILE ; } extern "C" { pub fn fmemopen (__s : * mut :: std :: os :: raw :: c_void , __len : usize , __modes : * const :: std :: os :: raw :: c_char) -> * mut FILE ; } extern "C" { pub fn open_memstream (__bufloc : * mut * mut :: std :: os :: raw :: c_char , __sizeloc : * mut usize) -> * mut FILE ; } extern "C" { pub fn setbuf (__stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char) ; } extern "C" { pub fn setvbuf (__stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __modes : :: std :: os :: raw :: c_int , __n : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setbuffer (__stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __size : usize) ; } extern "C" { pub fn setlinebuf (__stream : * mut FILE) ; } extern "C" { pub fn fprintf (__stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn printf (__format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sprintf (__s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfprintf (__s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vprintf (__format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsprintf (__s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn snprintf (__s : * mut :: std :: os :: raw :: c_char , __maxlen : :: std :: os :: raw :: c_ulong , __format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsnprintf (__s : * mut :: std :: os :: raw :: c_char , __maxlen : :: std :: os :: raw :: c_ulong , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vasprintf (__ptr : * mut * mut :: std :: os :: raw :: c_char , __f : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __asprintf (__ptr : * mut * mut :: std :: os :: raw :: c_char , __fmt : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn asprintf (__ptr : * mut * mut :: std :: os :: raw :: c_char , __fmt : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vdprintf (__fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn dprintf (__fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fscanf (__stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn scanf (__format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sscanf (__s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}__isoc99_fscanf"] pub fn fscanf1 (__stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}__isoc99_scanf"] pub fn scanf1 (__format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}__isoc99_sscanf"] pub fn sscanf1 (__s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfscanf (__s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vscanf (__format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsscanf (__s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}__isoc99_vfscanf"] pub fn vfscanf1 (__s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}__isoc99_vscanf"] pub fn vscanf1 (__format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}__isoc99_vsscanf"] pub fn vsscanf1 (__s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc_unlocked (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar_unlocked () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc_unlocked (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc (__c : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc (__c : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar (__c : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc_unlocked (__c : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc_unlocked (__c : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar_unlocked (__c : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getw (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putw (__w : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgets (__s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __getdelim (__lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> __ssize_t ; } extern "C" { pub fn getdelim (__lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> __ssize_t ; } extern "C" { pub fn getline (__lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __stream : * mut FILE) -> __ssize_t ; } extern "C" { pub fn fputs (__s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn puts (__s : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ungetc (__c : :: std :: os :: raw :: c_int , __stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fread (__ptr : * mut :: std :: os :: raw :: c_void , __size : :: std :: os :: raw :: c_ulong , __n : :: std :: os :: raw :: c_ulong , __stream : * mut FILE) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn fwrite (__ptr : * const :: std :: os :: raw :: c_void , __size : :: std :: os :: raw :: c_ulong , __n : :: std :: os :: raw :: c_ulong , __s : * mut FILE) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn fread_unlocked (__ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE) -> usize ; } extern "C" { pub fn fwrite_unlocked (__ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE) -> usize ; } extern "C" { pub fn fseek (__stream : * mut FILE , __off : :: std :: os :: raw :: c_long , __whence : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftell (__stream : * mut FILE) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn rewind (__stream : * mut FILE) ; } extern "C" { pub fn fseeko (__stream : * mut FILE , __off : __off_t , __whence : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftello (__stream : * mut FILE) -> __off_t ; } extern "C" { pub fn fgetpos (__stream : * mut FILE , __pos : * mut fpos_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fsetpos (__stream : * mut FILE , __pos : * const fpos_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr (__stream : * mut FILE) ; } extern "C" { pub fn feof (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr_unlocked (__stream : * mut FILE) ; } extern "C" { pub fn feof_unlocked (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror_unlocked (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn perror (__s : * const :: std :: os :: raw :: c_char) ; } extern "C" { pub fn fileno (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fileno_unlocked (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pclose (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn popen (__command : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char) -> * mut FILE ; } extern "C" { pub fn ctermid (__s : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn flockfile (__stream : * mut FILE) ; } extern "C" { pub fn ftrylockfile (__stream : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn funlockfile (__stream : * mut FILE) ; } extern "C" { pub fn __uflow (arg1 : * mut FILE) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __overflow (arg1 : * mut FILE , arg2 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memcpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memmove (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memccpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memset (__s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memcmp (__s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __memcmpeq (__s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memchr (__s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcat (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncat (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcoll (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __locale_struct { pub __locales : [* mut __locale_data ; 13usize] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [* const :: std :: os :: raw :: c_char ; 13usize] , } # [test] fn bindgen_test_layout___locale_struct () { const UNINIT : :: std :: mem :: MaybeUninit < __locale_struct > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __locale_struct > () , 232usize , concat ! ("Size of: " , stringify ! (__locale_struct))) ; assert_eq ! (:: std :: mem :: align_of :: < __locale_struct > () , 8usize , concat ! ("Alignment of " , stringify ! (__locale_struct))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __locales) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__locale_struct) , "::" , stringify ! (__locales))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __ctype_b) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (__locale_struct) , "::" , stringify ! (__ctype_b))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __ctype_tolower) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (__locale_struct) , "::" , stringify ! (__ctype_tolower))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __ctype_toupper) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (__locale_struct) , "::" , stringify ! (__ctype_toupper))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __names) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (__locale_struct) , "::" , stringify ! (__names))) ; } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { pub fn strcoll_l (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : locale_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm_l (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : locale_t) -> usize ; } extern "C" { pub fn strdup (__s : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strndup (__string : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strchr (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrchr (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strchrnul (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcspn (__s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strspn (__s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strpbrk (__s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strstr (__haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok (__s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __strtok_r (__s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok_r (__s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcasestr (__haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn memmem (__haystack : * const :: std :: os :: raw :: c_void , __haystacklen : usize , __needle : * const :: std :: os :: raw :: c_void , __needlelen : usize) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn __mempcpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn mempcpy (__dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strlen (__s : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strnlen (__string : * const :: std :: os :: raw :: c_char , __maxlen : usize) -> usize ; } extern "C" { pub fn strerror (__errnum : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [link_name = "\u{1}__xpg_strerror_r"] pub fn strerror_r (__errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strerror_l (__errnum : :: std :: os :: raw :: c_int , __l : locale_t) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn bcmp (__s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn bcopy (__src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) ; } extern "C" { pub fn bzero (__s : * mut :: std :: os :: raw :: c_void , __n : :: std :: os :: raw :: c_ulong) ; } extern "C" { pub fn index (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn rindex (__s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ffs (__i : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ffsl (__l : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ffsll (__ll : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcasecmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncasecmp (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcasecmp_l (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __loc : locale_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncasecmp_l (__s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize , __loc : locale_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn explicit_bzero (__s : * mut :: std :: os :: raw :: c_void , __n : usize) ; } extern "C" { pub fn strsep (__stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strsignal (__sig : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpncpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpncpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strlcpy (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strlcat (__dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong ; } # [repr (C)] # [repr (align (16))] # [derive (Debug , Copy , Clone)] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : u128 , } # [test] fn bindgen_test_layout_max_align_t () { const UNINIT : :: std :: mem :: MaybeUninit < max_align_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < max_align_t > () , 32usize , concat ! ("Size of: " , stringify ! (max_align_t))) ; assert_eq ! (:: std :: mem :: align_of :: < max_align_t > () , 16usize , concat ! ("Alignment of " , stringify ! (max_align_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __clang_max_align_nonce1) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (max_align_t) , "::" , stringify ! (__clang_max_align_nonce1))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . __clang_max_align_nonce2) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (max_align_t) , "::" , stringify ! (__clang_max_align_nonce2))) ; } # [doc = " pointer to a malloc function, supporting client overriding memory\n  allocation routines"] pub type yajl_malloc_func = :: std :: option :: Option < unsafe extern "C" fn (ctx : * mut :: std :: os :: raw :: c_void , sz : usize) -> * mut :: std :: os :: raw :: c_void > ; # [doc = " pointer to a free function, supporting client overriding memory\n  allocation routines"] pub type yajl_free_func = :: std :: option :: Option < unsafe extern "C" fn (ctx : * mut :: std :: os :: raw :: c_void , ptr : * mut :: std :: os :: raw :: c_void) > ; # [doc = " pointer to a realloc function which can resize an allocation."] pub type yajl_realloc_func = :: std :: option :: Option < unsafe extern "C" fn (ctx : * mut :: std :: os :: raw :: c_void , ptr : * mut :: std :: os :: raw :: c_void , sz : usize) -> * mut :: std :: os :: raw :: c_void > ; # [doc = " A structure which can be passed to yajl_*_alloc routines to allow the\n  client to specify memory allocation functions to be used."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct yajl_alloc_funcs { # [doc = " pointer to a function that can allocate uninitialized memory"] pub malloc : yajl_malloc_func , # [doc = " pointer to a function that can resize memory allocations"] pub realloc : yajl_realloc_func , # [doc = " pointer to a function that can free memory allocated using\n  reallocFunction or mallocFunction"] pub free : yajl_free_func , # [doc = " a context pointer that will be passed to above allocation routines"] pub ctx : * mut :: std :: os :: raw :: c_void , } # [test] fn bindgen_test_layout_yajl_alloc_funcs () { const UNINIT : :: std :: mem :: MaybeUninit < yajl_alloc_funcs > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < yajl_alloc_funcs > () , 32usize , concat ! ("Size of: " , stringify ! (yajl_alloc_funcs))) ; assert_eq ! (:: std :: mem :: align_of :: < yajl_alloc_funcs > () , 8usize , concat ! ("Alignment of " , stringify ! (yajl_alloc_funcs))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . malloc) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_alloc_funcs) , "::" , stringify ! (malloc))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . realloc) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (yajl_alloc_funcs) , "::" , stringify ! (realloc))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . free) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (yajl_alloc_funcs) , "::" , stringify ! (free))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ctx) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (yajl_alloc_funcs) , "::" , stringify ! (ctx))) ; } pub const yajl_type_yajl_t_string : yajl_type = 1 ; pub const yajl_type_yajl_t_number : yajl_type = 2 ; pub const yajl_type_yajl_t_object : yajl_type = 3 ; pub const yajl_type_yajl_t_array : yajl_type = 4 ; pub const yajl_type_yajl_t_true : yajl_type = 5 ; pub const yajl_type_yajl_t_false : yajl_type = 6 ; pub const yajl_type_yajl_t_null : yajl_type = 7 ; # [doc = " The any type isn't valid for yajl_val_s.type, but can be\n  used as an argument to routines like yajl_tree_get()."] pub const yajl_type_yajl_t_any : yajl_type = 8 ; # [doc = " possible data types that a yajl_val_s can hold"] pub type yajl_type = :: std :: os :: raw :: c_uint ; # [doc = " A pointer to a node in the parse tree"] pub type yajl_val = * mut yajl_val_s ; # [doc = " A JSON value representation capable of holding one of the seven\n types above. For \"string\", \"number\", \"object\", and \"array\"\n additional data is available in the union.  The \"YAJL_IS_*\"\n and \"YAJL_GET_*\" macros below allow type checking and convenient\n value extraction."] # [repr (C)] # [derive (Copy , Clone)] pub struct yajl_val_s { # [doc = " Type of the value contained. Use the \"YAJL_IS_*\" macros to check for a\n specific type."] pub type_ : yajl_type , pub u : yajl_val_s__bindgen_ty_1 , } # [doc = " Type-specific data. You may use the \"YAJL_GET_*\" macros to access these\n members."] # [repr (C)] # [derive (Copy , Clone)] pub union yajl_val_s__bindgen_ty_1 { pub string : * mut :: std :: os :: raw :: c_char , pub number : yajl_val_s__bindgen_ty_1__bindgen_ty_1 , pub object : yajl_val_s__bindgen_ty_1__bindgen_ty_2 , pub array : yajl_val_s__bindgen_ty_1__bindgen_ty_3 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct yajl_val_s__bindgen_ty_1__bindgen_ty_1 { pub i : :: std :: os :: raw :: c_longlong , pub d : f64 , pub r : * mut :: std :: os :: raw :: c_char , # [doc = " Signals whether the \\em i and \\em d members are\n valid. See \\c YAJL_NUMBER_INT_VALID and\n \\c YAJL_NUMBER_DOUBLE_VALID."] pub flags : :: std :: os :: raw :: c_uint , } # [test] fn bindgen_test_layout_yajl_val_s__bindgen_ty_1__bindgen_ty_1 () { const UNINIT : :: std :: mem :: MaybeUninit < yajl_val_s__bindgen_ty_1__bindgen_ty_1 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < yajl_val_s__bindgen_ty_1__bindgen_ty_1 > () , 32usize , concat ! ("Size of: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: < yajl_val_s__bindgen_ty_1__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . i) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (i))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . d) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (d))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . r) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (r))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . flags) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (flags))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct yajl_val_s__bindgen_ty_1__bindgen_ty_2 { pub keys : * mut * const :: std :: os :: raw :: c_char , pub values : * mut yajl_val , pub len : usize , } # [test] fn bindgen_test_layout_yajl_val_s__bindgen_ty_1__bindgen_ty_2 () { const UNINIT : :: std :: mem :: MaybeUninit < yajl_val_s__bindgen_ty_1__bindgen_ty_2 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < yajl_val_s__bindgen_ty_1__bindgen_ty_2 > () , 24usize , concat ! ("Size of: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_2))) ; assert_eq ! (:: std :: mem :: align_of :: < yajl_val_s__bindgen_ty_1__bindgen_ty_2 > () , 8usize , concat ! ("Alignment of " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_2))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_2) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_2) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_2) , "::" , stringify ! (len))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct yajl_val_s__bindgen_ty_1__bindgen_ty_3 { pub values : * mut yajl_val , pub len : usize , } # [test] fn bindgen_test_layout_yajl_val_s__bindgen_ty_1__bindgen_ty_3 () { const UNINIT : :: std :: mem :: MaybeUninit < yajl_val_s__bindgen_ty_1__bindgen_ty_3 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < yajl_val_s__bindgen_ty_1__bindgen_ty_3 > () , 16usize , concat ! ("Size of: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_3))) ; assert_eq ! (:: std :: mem :: align_of :: < yajl_val_s__bindgen_ty_1__bindgen_ty_3 > () , 8usize , concat ! ("Alignment of " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_3))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_3) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1__bindgen_ty_3) , "::" , stringify ! (len))) ; } # [test] fn bindgen_test_layout_yajl_val_s__bindgen_ty_1 () { const UNINIT : :: std :: mem :: MaybeUninit < yajl_val_s__bindgen_ty_1 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < yajl_val_s__bindgen_ty_1 > () , 32usize , concat ! ("Size of: " , stringify ! (yajl_val_s__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: < yajl_val_s__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (yajl_val_s__bindgen_ty_1))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . string) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1) , "::" , stringify ! (string))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . number) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1) , "::" , stringify ! (number))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . object) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1) , "::" , stringify ! (object))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . array) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s__bindgen_ty_1) , "::" , stringify ! (array))) ; } # [test] fn bindgen_test_layout_yajl_val_s () { const UNINIT : :: std :: mem :: MaybeUninit < yajl_val_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < yajl_val_s > () , 40usize , concat ! ("Size of: " , stringify ! (yajl_val_s))) ; assert_eq ! (:: std :: mem :: align_of :: < yajl_val_s > () , 8usize , concat ! ("Alignment of " , stringify ! (yajl_val_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . u) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (yajl_val_s) , "::" , stringify ! (u))) ; } extern "C" { # [doc = " Parse a string.\n\n Parses an null-terminated string containing JSON data and returns a pointer\n to the top-level value (root of the parse tree).\n\n \\param input              Pointer to a null-terminated utf8 string containing\n                           JSON data.\n \\param error_buffer       Pointer to a buffer in which an error message will\n                           be stored if \\em yajl_tree_parse fails, or\n                           \\c NULL. The buffer will be initialized before\n                           parsing, so its content will be destroyed even if\n                           \\em yajl_tree_parse succeeds.\n \\param error_buffer_size  Size of the memory area pointed to by\n                           \\em error_buffer_size. If \\em error_buffer_size is\n                           \\c NULL, this argument is ignored.\n\n \\returns Pointer to the top-level value or \\c NULL on error. The memory\n pointed to must be freed using \\em yajl_tree_free. In case of an error, a\n null terminated message describing the error in more detail is stored in\n \\em error_buffer if it is not \\c NULL."] pub fn yajl_tree_parse (input : * const :: std :: os :: raw :: c_char , error_buffer : * mut :: std :: os :: raw :: c_char , error_buffer_size : usize) -> yajl_val ; } extern "C" { # [doc = " Free a parse tree returned by \"yajl_tree_parse\".\n\n \\param v Pointer to a JSON value returned by \"yajl_tree_parse\". Passing NULL\n is valid and results in a no-op."] pub fn yajl_tree_free (v : yajl_val) ; } extern "C" { # [doc = " Access a nested value inside a tree.\n\n \\param parent the node under which you'd like to extract values.\n \\param path A null terminated array of strings, each the name of an object key\n \\param type the yajl_type of the object you seek, or yajl_t_any if any will do.\n\n \\returns a pointer to the found value, or NULL if we came up empty.\n\n Future Ideas:  it'd be nice to move path to a string and implement support for\n a teeny tiny micro language here, so you can extract array elements, do things\n like .first and .last, even .length.  Inspiration from JSONPath and css selectors?\n No it wouldn't be fast, but that's not what this API is about."] pub fn yajl_tree_get (parent : yajl_val , path : * mut * const :: std :: os :: raw :: c_char , type_ : yajl_type) -> yajl_val ; } # [doc = " no error"] pub const yajl_gen_status_yajl_gen_status_ok : yajl_gen_status = 0 ; # [doc = " at a point where a map key is generated, a function other than\n  yajl_gen_string was called"] pub const yajl_gen_status_yajl_gen_keys_must_be_strings : yajl_gen_status = 1 ; # [doc = " YAJL's maximum generation depth was exceeded.  see\n  YAJL_MAX_DEPTH"] pub const yajl_gen_status_yajl_max_depth_exceeded : yajl_gen_status = 2 ; # [doc = " A generator function (yajl_gen_XXX) was called while in an error\n  state"] pub const yajl_gen_status_yajl_gen_in_error_state : yajl_gen_status = 3 ; # [doc = " A complete JSON document has been generated"] pub const yajl_gen_status_yajl_gen_generation_complete : yajl_gen_status = 4 ; # [doc = " yajl_gen_double was passed an invalid floating point value\n  (infinity or NaN)."] pub const yajl_gen_status_yajl_gen_invalid_number : yajl_gen_status = 5 ; # [doc = " A print callback was passed in, so there is no internal\n buffer to get from"] pub const yajl_gen_status_yajl_gen_no_buf : yajl_gen_status = 6 ; # [doc = " returned from yajl_gen_string() when the yajl_gen_validate_utf8\n  option is enabled and an invalid was passed by client code."] pub const yajl_gen_status_yajl_gen_invalid_string : yajl_gen_status = 7 ; # [doc = " generator status codes"] pub type yajl_gen_status = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct yajl_gen_t { _unused : [u8 ; 0] , } # [doc = " an opaque handle to a generator"] pub type yajl_gen = * mut yajl_gen_t ; # [doc = " a callback used for \"printing\" the results."] pub type yajl_print_t = :: std :: option :: Option < unsafe extern "C" fn (ctx : * mut :: std :: os :: raw :: c_void , str_ : * const :: std :: os :: raw :: c_char , len : usize) > ; # [doc = " generate indented (beautiful) output"] pub const yajl_gen_option_yajl_gen_beautify : yajl_gen_option = 1 ; # [doc = " Set an indent string which is used when yajl_gen_beautify\n is enabled.  Maybe something like \\\\t or some number of\n spaces.  The default is four spaces ' '."] pub const yajl_gen_option_yajl_gen_indent_string : yajl_gen_option = 2 ; # [doc = " Set a function and context argument that should be used to\n output generated json.  the function should conform to the\n yajl_print_t prototype while the context argument is a\n void * of your choosing.\n\n example:\n   yajl_gen_config(g, yajl_gen_print_callback, myFunc, myVoidPtr);"] pub const yajl_gen_option_yajl_gen_print_callback : yajl_gen_option = 4 ; # [doc = " Normally the generator does not validate that strings you\n pass to it via yajl_gen_string() are valid UTF8.  Enabling\n this option will cause it to do so."] pub const yajl_gen_option_yajl_gen_validate_utf8 : yajl_gen_option = 8 ; # [doc = " the forward solidus (slash or '/' in human) is not required to be\n escaped in json text.  By default, YAJL will not escape it in the\n iterest of saving bytes.  Setting this flag will cause YAJL to\n always escape '/' in generated JSON strings."] pub const yajl_gen_option_yajl_gen_escape_solidus : yajl_gen_option = 16 ; # [doc = " configuration parameters for the parser, these may be passed to\n  yajl_gen_config() along with option specific argument(s).  In general,\n  all configuration parameters default to *off*."] pub type yajl_gen_option = :: std :: os :: raw :: c_uint ; extern "C" { # [doc = " allow the modification of generator options subsequent to handle\n  allocation (via yajl_alloc)\n  \\returns zero in case of errors, non-zero otherwise"] pub fn yajl_gen_config (g : yajl_gen , opt : yajl_gen_option , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " allocate a generator handle\n  \\param allocFuncs an optional pointer to a structure which allows\n                    the client to overide the memory allocation\n                    used by yajl.  May be NULL, in which case\n                    malloc/free/realloc will be used.\n\n  \\returns an allocated handle on success, NULL on failure (bad params)"] pub fn yajl_gen_alloc (allocFuncs : * const yajl_alloc_funcs) -> yajl_gen ; } extern "C" { # [doc = " free a generator handle"] pub fn yajl_gen_free (handle : yajl_gen) ; } extern "C" { pub fn yajl_gen_integer (hand : yajl_gen , number : :: std :: os :: raw :: c_longlong) -> yajl_gen_status ; } extern "C" { # [doc = " generate a floating point number.  number may not be infinity or\n  NaN, as these have no representation in JSON.  In these cases the\n  generator will return 'yajl_gen_invalid_number'"] pub fn yajl_gen_double (hand : yajl_gen , number : f64) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_number (hand : yajl_gen , num : * const :: std :: os :: raw :: c_char , len : usize) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_string (hand : yajl_gen , str_ : * const :: std :: os :: raw :: c_uchar , len : usize) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_null (hand : yajl_gen) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_bool (hand : yajl_gen , boolean : :: std :: os :: raw :: c_int) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_map_open (hand : yajl_gen) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_map_close (hand : yajl_gen) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_array_open (hand : yajl_gen) -> yajl_gen_status ; } extern "C" { pub fn yajl_gen_array_close (hand : yajl_gen) -> yajl_gen_status ; } extern "C" { # [doc = " access the null terminated generator buffer.  If incrementally\n  outputing JSON, one should call yajl_gen_clear to clear the\n  buffer.  This allows stream generation."] pub fn yajl_gen_get_buf (hand : yajl_gen , buf : * mut * const :: std :: os :: raw :: c_uchar , len : * mut usize) -> yajl_gen_status ; } extern "C" { # [doc = " clear yajl's output buffer, but maintain all internal generation\n  state.  This function will not \"reset\" the generator state, and is\n  intended to enable incremental JSON outputing."] pub fn yajl_gen_clear (hand : yajl_gen) ; } extern "C" { # [doc = " Reset the generator state.  Allows a client to generate multiple\n  json entities in a stream. The \"sep\" string will be inserted to\n  separate the previously generated entity from the current,\n  NULL means *no separation* of entites (clients beware, generating\n  multiple JSON numbers without a separator, for instance, will result in ambiguous output)\n\n  Note: this call will not clear yajl's output buffer.  This\n  may be accomplished explicitly by calling yajl_gen_clear()"] pub fn yajl_gen_reset (hand : yajl_gen , sep : * const :: std :: os :: raw :: c_char) ; } pub type parser_error = * mut :: std :: os :: raw :: c_char ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct parser_context { pub options : :: std :: os :: raw :: c_uint , pub errfile : * mut FILE , } # [test] fn bindgen_test_layout_parser_context () { const UNINIT : :: std :: mem :: MaybeUninit < parser_context > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < parser_context > () , 16usize , concat ! ("Size of: " , stringify ! (parser_context))) ; assert_eq ! (:: std :: mem :: align_of :: < parser_context > () , 8usize , concat ! ("Alignment of " , stringify ! (parser_context))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . options) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (parser_context) , "::" , stringify ! (options))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . errfile) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (parser_context) , "::" , stringify ! (errfile))) ; } extern "C" { pub fn gen_yajl_object_residual (obj : yajl_val , g : yajl_gen , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn map_uint (ctx : * mut :: std :: os :: raw :: c_void , num : :: std :: os :: raw :: c_ulonglong) -> yajl_gen_status ; } extern "C" { pub fn map_int (ctx : * mut :: std :: os :: raw :: c_void , num : :: std :: os :: raw :: c_longlong) -> yajl_gen_status ; } extern "C" { pub fn json_gen_init (g : * mut yajl_gen , ctx : * const parser_context) -> bool ; } extern "C" { pub fn get_val (tree : yajl_val , name : * const :: std :: os :: raw :: c_char , type_ : yajl_type) -> yajl_val ; } extern "C" { pub fn safe_strdup (src : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn safe_malloc (size : usize) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn common_safe_double (numstr : * const :: std :: os :: raw :: c_char , converted : * mut f64) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_uint8 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut u8) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_uint16 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut u16) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_uint32 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut u32) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_uint64 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut u64) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_uint (numstr : * const :: std :: os :: raw :: c_char , converted : * mut :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_int8 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut i8) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_int16 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut i16) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_int32 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut i32) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_int64 (numstr : * const :: std :: os :: raw :: c_char , converted : * mut i64) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn common_safe_int (numstr : * const :: std :: os :: raw :: c_char , converted : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct json_map_int_int { pub keys : * mut :: std :: os :: raw :: c_int , pub values : * mut :: std :: os :: raw :: c_int , pub len : usize , } # [test] fn bindgen_test_layout_json_map_int_int () { const UNINIT : :: std :: mem :: MaybeUninit < json_map_int_int > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < json_map_int_int > () , 24usize , concat ! ("Size of: " , stringify ! (json_map_int_int))) ; assert_eq ! (:: std :: mem :: align_of :: < json_map_int_int > () , 8usize , concat ! ("Alignment of " , stringify ! (json_map_int_int))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (json_map_int_int) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (json_map_int_int) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (json_map_int_int) , "::" , stringify ! (len))) ; } extern "C" { pub fn free_json_map_int_int (map : * mut json_map_int_int) ; } extern "C" { pub fn make_json_map_int_int (src : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut json_map_int_int ; } extern "C" { pub fn gen_json_map_int_int (ctx : * mut :: std :: os :: raw :: c_void , map : * const json_map_int_int , ptx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn append_json_map_int_int (map : * mut json_map_int_int , key : :: std :: os :: raw :: c_int , val : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct json_map_int_bool { pub keys : * mut :: std :: os :: raw :: c_int , pub values : * mut bool , pub len : usize , } # [test] fn bindgen_test_layout_json_map_int_bool () { const UNINIT : :: std :: mem :: MaybeUninit < json_map_int_bool > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < json_map_int_bool > () , 24usize , concat ! ("Size of: " , stringify ! (json_map_int_bool))) ; assert_eq ! (:: std :: mem :: align_of :: < json_map_int_bool > () , 8usize , concat ! ("Alignment of " , stringify ! (json_map_int_bool))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (json_map_int_bool) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (json_map_int_bool) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (json_map_int_bool) , "::" , stringify ! (len))) ; } extern "C" { pub fn free_json_map_int_bool (map : * mut json_map_int_bool) ; } extern "C" { pub fn make_json_map_int_bool (src : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut json_map_int_bool ; } extern "C" { pub fn gen_json_map_int_bool (ctx : * mut :: std :: os :: raw :: c_void , map : * const json_map_int_bool , ptx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn append_json_map_int_bool (map : * mut json_map_int_bool , key : :: std :: os :: raw :: c_int , val : bool) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct json_map_int_string { pub keys : * mut :: std :: os :: raw :: c_int , pub values : * mut * mut :: std :: os :: raw :: c_char , pub len : usize , } # [test] fn bindgen_test_layout_json_map_int_string () { const UNINIT : :: std :: mem :: MaybeUninit < json_map_int_string > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < json_map_int_string > () , 24usize , concat ! ("Size of: " , stringify ! (json_map_int_string))) ; assert_eq ! (:: std :: mem :: align_of :: < json_map_int_string > () , 8usize , concat ! ("Alignment of " , stringify ! (json_map_int_string))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (json_map_int_string) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (json_map_int_string) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (json_map_int_string) , "::" , stringify ! (len))) ; } extern "C" { pub fn free_json_map_int_string (map : * mut json_map_int_string) ; } extern "C" { pub fn make_json_map_int_string (src : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut json_map_int_string ; } extern "C" { pub fn gen_json_map_int_string (ctx : * mut :: std :: os :: raw :: c_void , map : * const json_map_int_string , ptx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn append_json_map_int_string (map : * mut json_map_int_string , key : :: std :: os :: raw :: c_int , val : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct json_map_string_int { pub keys : * mut * mut :: std :: os :: raw :: c_char , pub values : * mut :: std :: os :: raw :: c_int , pub len : usize , } # [test] fn bindgen_test_layout_json_map_string_int () { const UNINIT : :: std :: mem :: MaybeUninit < json_map_string_int > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < json_map_string_int > () , 24usize , concat ! ("Size of: " , stringify ! (json_map_string_int))) ; assert_eq ! (:: std :: mem :: align_of :: < json_map_string_int > () , 8usize , concat ! ("Alignment of " , stringify ! (json_map_string_int))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (json_map_string_int) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (json_map_string_int) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (json_map_string_int) , "::" , stringify ! (len))) ; } extern "C" { pub fn free_json_map_string_int (map : * mut json_map_string_int) ; } extern "C" { pub fn make_json_map_string_int (src : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut json_map_string_int ; } extern "C" { pub fn gen_json_map_string_int (ctx : * mut :: std :: os :: raw :: c_void , map : * const json_map_string_int , ptx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn append_json_map_string_int (map : * mut json_map_string_int , key : * const :: std :: os :: raw :: c_char , val : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct json_map_string_bool { pub keys : * mut * mut :: std :: os :: raw :: c_char , pub values : * mut bool , pub len : usize , } # [test] fn bindgen_test_layout_json_map_string_bool () { const UNINIT : :: std :: mem :: MaybeUninit < json_map_string_bool > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < json_map_string_bool > () , 24usize , concat ! ("Size of: " , stringify ! (json_map_string_bool))) ; assert_eq ! (:: std :: mem :: align_of :: < json_map_string_bool > () , 8usize , concat ! ("Alignment of " , stringify ! (json_map_string_bool))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (json_map_string_bool) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (json_map_string_bool) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (json_map_string_bool) , "::" , stringify ! (len))) ; } extern "C" { pub fn free_json_map_string_bool (map : * mut json_map_string_bool) ; } extern "C" { pub fn make_json_map_string_bool (src : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut json_map_string_bool ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct json_map_string_int64 { pub keys : * mut * mut :: std :: os :: raw :: c_char , pub values : * mut i64 , pub len : usize , } # [test] fn bindgen_test_layout_json_map_string_int64 () { const UNINIT : :: std :: mem :: MaybeUninit < json_map_string_int64 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < json_map_string_int64 > () , 24usize , concat ! ("Size of: " , stringify ! (json_map_string_int64))) ; assert_eq ! (:: std :: mem :: align_of :: < json_map_string_int64 > () , 8usize , concat ! ("Alignment of " , stringify ! (json_map_string_int64))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (json_map_string_int64) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (json_map_string_int64) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (json_map_string_int64) , "::" , stringify ! (len))) ; } extern "C" { pub fn free_json_map_string_int64 (map : * mut json_map_string_int64) ; } extern "C" { pub fn make_json_map_string_int64 (src : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut json_map_string_int64 ; } extern "C" { pub fn gen_json_map_string_int64 (ctx : * mut :: std :: os :: raw :: c_void , map : * const json_map_string_int64 , ptx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn append_json_map_string_int64 (map : * mut json_map_string_int64 , key : * const :: std :: os :: raw :: c_char , val : i64) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn gen_json_map_string_bool (ctx : * mut :: std :: os :: raw :: c_void , map : * const json_map_string_bool , ptx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn append_json_map_string_bool (map : * mut json_map_string_bool , key : * const :: std :: os :: raw :: c_char , val : bool) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct json_map_string_string { pub keys : * mut * mut :: std :: os :: raw :: c_char , pub values : * mut * mut :: std :: os :: raw :: c_char , pub len : usize , } # [test] fn bindgen_test_layout_json_map_string_string () { const UNINIT : :: std :: mem :: MaybeUninit < json_map_string_string > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < json_map_string_string > () , 24usize , concat ! ("Size of: " , stringify ! (json_map_string_string))) ; assert_eq ! (:: std :: mem :: align_of :: < json_map_string_string > () , 8usize , concat ! ("Alignment of " , stringify ! (json_map_string_string))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . keys) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (json_map_string_string) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . values) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (json_map_string_string) , "::" , stringify ! (values))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (json_map_string_string) , "::" , stringify ! (len))) ; } extern "C" { pub fn free_json_map_string_string (map : * mut json_map_string_string) ; } extern "C" { pub fn make_json_map_string_string (src : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut json_map_string_string ; } extern "C" { pub fn gen_json_map_string_string (ctx : * mut :: std :: os :: raw :: c_void , map : * const json_map_string_string , ptx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn append_json_map_string_string (map : * mut json_map_string_string , key : * const :: std :: os :: raw :: c_char , val : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn json_marshal_string (str_ : * const :: std :: os :: raw :: c_char , length : usize , ctx : * const parser_context , err : * mut parser_error) -> * mut :: std :: os :: raw :: c_char ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_hook { pub path : * mut :: std :: os :: raw :: c_char , pub args : * mut * mut :: std :: os :: raw :: c_char , pub args_len : usize , pub env : * mut * mut :: std :: os :: raw :: c_char , pub env_len : usize , pub timeout : :: std :: os :: raw :: c_int , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_hook () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_hook > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_hook > () , 64usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_hook))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_hook > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_hook))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_hook) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . args) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_hook) , "::" , stringify ! (args))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . args_len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_hook) , "::" , stringify ! (args_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . env) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_hook) , "::" , stringify ! (env))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . env_len) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_hook) , "::" , stringify ! (env_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . timeout) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_hook) , "::" , stringify ! (timeout))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_hook) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_hook { # [inline] pub fn timeout_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_timeout_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (timeout_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let timeout_present : u32 = unsafe { :: std :: mem :: transmute (timeout_present) } ; timeout_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_hook (ptr : * mut runtime_spec_schema_defs_hook) ; } extern "C" { pub fn make_runtime_spec_schema_defs_hook (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_hook ; } extern "C" { pub fn gen_runtime_spec_schema_defs_hook (g : yajl_gen , ptr : * const runtime_spec_schema_defs_hook , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_id_mapping { pub container_id : u32 , pub host_id : u32 , pub size : u32 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_id_mapping () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_id_mapping > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_id_mapping > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_id_mapping))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_id_mapping > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_id_mapping))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . container_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_id_mapping) , "::" , stringify ! (container_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . host_id) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_id_mapping) , "::" , stringify ! (host_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . size) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_id_mapping) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_id_mapping) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_id_mapping { # [inline] pub fn container_id_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_container_id_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn host_id_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_host_id_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn size_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_size_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (container_id_present : :: std :: os :: raw :: c_uint , host_id_present : :: std :: os :: raw :: c_uint , size_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let container_id_present : u32 = unsafe { :: std :: mem :: transmute (container_id_present) } ; container_id_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let host_id_present : u32 = unsafe { :: std :: mem :: transmute (host_id_present) } ; host_id_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let size_present : u32 = unsafe { :: std :: mem :: transmute (size_present) } ; size_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_id_mapping (ptr : * mut runtime_spec_schema_defs_id_mapping) ; } extern "C" { pub fn make_runtime_spec_schema_defs_id_mapping (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_id_mapping ; } extern "C" { pub fn gen_runtime_spec_schema_defs_id_mapping (g : yajl_gen , ptr : * const runtime_spec_schema_defs_id_mapping , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_mount { pub source : * mut :: std :: os :: raw :: c_char , pub destination : * mut :: std :: os :: raw :: c_char , pub options : * mut * mut :: std :: os :: raw :: c_char , pub options_len : usize , pub type_ : * mut :: std :: os :: raw :: c_char , pub uid_mappings : * mut * mut runtime_spec_schema_defs_id_mapping , pub uid_mappings_len : usize , pub gid_mappings : * mut * mut runtime_spec_schema_defs_id_mapping , pub gid_mappings_len : usize , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_mount () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_mount > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_mount > () , 80usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_mount))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_mount > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_mount))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . source) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (source))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . destination) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (destination))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . options) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (options))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . options_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (options_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . uid_mappings) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (uid_mappings))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . uid_mappings_len) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (uid_mappings_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gid_mappings) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (gid_mappings))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gid_mappings_len) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (gid_mappings_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_mount) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_defs_mount (ptr : * mut runtime_spec_schema_defs_mount) ; } extern "C" { pub fn make_runtime_spec_schema_defs_mount (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_mount ; } extern "C" { pub fn gen_runtime_spec_schema_defs_mount (g : yajl_gen , ptr : * const runtime_spec_schema_defs_mount , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_personality { pub domain : * mut :: std :: os :: raw :: c_char , pub flags : * mut * mut :: std :: os :: raw :: c_char , pub flags_len : usize , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_personality () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_personality > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_personality > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_personality))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_personality > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_personality))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . domain) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_personality) , "::" , stringify ! (domain))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . flags) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_personality) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . flags_len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_personality) , "::" , stringify ! (flags_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_personality) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_defs_linux_personality (ptr : * mut runtime_spec_schema_defs_linux_personality) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_personality (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_personality ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_personality (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_personality , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_syscall_arg { pub index : u32 , pub value : u64 , pub value_two : u64 , pub op : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_syscall_arg () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_syscall_arg > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_syscall_arg > () , 48usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_syscall_arg))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_syscall_arg > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_syscall_arg))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . index) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall_arg) , "::" , stringify ! (index))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . value) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall_arg) , "::" , stringify ! (value))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . value_two) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall_arg) , "::" , stringify ! (value_two))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . op) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall_arg) , "::" , stringify ! (op))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall_arg) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_syscall_arg { # [inline] pub fn index_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_index_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn value_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_value_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn value_two_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_value_two_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (index_present : :: std :: os :: raw :: c_uint , value_present : :: std :: os :: raw :: c_uint , value_two_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let index_present : u32 = unsafe { :: std :: mem :: transmute (index_present) } ; index_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let value_present : u32 = unsafe { :: std :: mem :: transmute (value_present) } ; value_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let value_two_present : u32 = unsafe { :: std :: mem :: transmute (value_two_present) } ; value_two_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_syscall_arg (ptr : * mut runtime_spec_schema_defs_linux_syscall_arg) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_syscall_arg (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_syscall_arg ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_syscall_arg (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_syscall_arg , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_syscall { pub names : * mut * mut :: std :: os :: raw :: c_char , pub names_len : usize , pub action : * mut :: std :: os :: raw :: c_char , pub errno_ret : u32 , pub args : * mut * mut runtime_spec_schema_defs_linux_syscall_arg , pub args_len : usize , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_syscall () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_syscall > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_syscall > () , 64usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_syscall))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_syscall > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_syscall))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . names) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall) , "::" , stringify ! (names))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . names_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall) , "::" , stringify ! (names_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall) , "::" , stringify ! (action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . errno_ret) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall) , "::" , stringify ! (errno_ret))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . args) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall) , "::" , stringify ! (args))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . args_len) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall) , "::" , stringify ! (args_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_syscall) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_syscall { # [inline] pub fn errno_ret_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_errno_ret_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (errno_ret_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let errno_ret_present : u32 = unsafe { :: std :: mem :: transmute (errno_ret_present) } ; errno_ret_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_syscall (ptr : * mut runtime_spec_schema_defs_linux_syscall) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_syscall (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_syscall ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_syscall (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_syscall , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_device { pub type_ : * mut :: std :: os :: raw :: c_char , pub path : * mut :: std :: os :: raw :: c_char , pub file_mode : :: std :: os :: raw :: c_int , pub major : i64 , pub minor : i64 , pub uid : uid_t , pub gid : gid_t , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_device () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_device > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_device > () , 64usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_device))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_device > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . file_mode) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (file_mode))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . major) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . minor) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . uid) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (uid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gid) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (gid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_device { # [inline] pub fn file_mode_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_file_mode_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn major_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_major_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn minor_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_minor_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn uid_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_uid_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn gid_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_gid_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (file_mode_present : :: std :: os :: raw :: c_uint , major_present : :: std :: os :: raw :: c_uint , minor_present : :: std :: os :: raw :: c_uint , uid_present : :: std :: os :: raw :: c_uint , gid_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let file_mode_present : u32 = unsafe { :: std :: mem :: transmute (file_mode_present) } ; file_mode_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let major_present : u32 = unsafe { :: std :: mem :: transmute (major_present) } ; major_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let minor_present : u32 = unsafe { :: std :: mem :: transmute (minor_present) } ; minor_present as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let uid_present : u32 = unsafe { :: std :: mem :: transmute (uid_present) } ; uid_present as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let gid_present : u32 = unsafe { :: std :: mem :: transmute (gid_present) } ; gid_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_device (ptr : * mut runtime_spec_schema_defs_linux_device) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_device (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_device ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_device (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_device , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_block_io_device { pub major : i64 , pub minor : i64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_block_io_device () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_block_io_device > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_block_io_device > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_block_io_device > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_block_io_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . major) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device) , "::" , stringify ! (major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . minor) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device) , "::" , stringify ! (minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_block_io_device { # [inline] pub fn major_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_major_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn minor_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_minor_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (major_present : :: std :: os :: raw :: c_uint , minor_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let major_present : u32 = unsafe { :: std :: mem :: transmute (major_present) } ; major_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let minor_present : u32 = unsafe { :: std :: mem :: transmute (minor_present) } ; minor_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_block_io_device (ptr : * mut runtime_spec_schema_defs_linux_block_io_device) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_block_io_device (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_block_io_device ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_block_io_device (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_block_io_device , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_block_io_device_weight { pub major : i64 , pub minor : i64 , pub weight : u16 , pub leaf_weight : u16 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_block_io_device_weight () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_block_io_device_weight > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_block_io_device_weight > () , 40usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_weight))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_block_io_device_weight > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_weight))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . major) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_weight) , "::" , stringify ! (major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . minor) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_weight) , "::" , stringify ! (minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . weight) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_weight) , "::" , stringify ! (weight))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . leaf_weight) as usize - ptr as usize } , 18usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_weight) , "::" , stringify ! (leaf_weight))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_weight) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_block_io_device_weight { # [inline] pub fn major_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_major_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn minor_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_minor_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn weight_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_weight_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn leaf_weight_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_leaf_weight_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (major_present : :: std :: os :: raw :: c_uint , minor_present : :: std :: os :: raw :: c_uint , weight_present : :: std :: os :: raw :: c_uint , leaf_weight_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let major_present : u32 = unsafe { :: std :: mem :: transmute (major_present) } ; major_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let minor_present : u32 = unsafe { :: std :: mem :: transmute (minor_present) } ; minor_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let weight_present : u32 = unsafe { :: std :: mem :: transmute (weight_present) } ; weight_present as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let leaf_weight_present : u32 = unsafe { :: std :: mem :: transmute (leaf_weight_present) } ; leaf_weight_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_block_io_device_weight (ptr : * mut runtime_spec_schema_defs_linux_block_io_device_weight) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_block_io_device_weight (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_block_io_device_weight ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_block_io_device_weight (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_block_io_device_weight , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_block_io_device_throttle { pub major : i64 , pub minor : i64 , pub rate : u64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_block_io_device_throttle () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_block_io_device_throttle > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_block_io_device_throttle > () , 40usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_throttle))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_block_io_device_throttle > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_throttle))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . major) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_throttle) , "::" , stringify ! (major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . minor) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_throttle) , "::" , stringify ! (minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rate) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_throttle) , "::" , stringify ! (rate))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_block_io_device_throttle) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_block_io_device_throttle { # [inline] pub fn major_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_major_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn minor_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_minor_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn rate_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_rate_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (major_present : :: std :: os :: raw :: c_uint , minor_present : :: std :: os :: raw :: c_uint , rate_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let major_present : u32 = unsafe { :: std :: mem :: transmute (major_present) } ; major_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let minor_present : u32 = unsafe { :: std :: mem :: transmute (minor_present) } ; minor_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let rate_present : u32 = unsafe { :: std :: mem :: transmute (rate_present) } ; rate_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_block_io_device_throttle (ptr : * mut runtime_spec_schema_defs_linux_block_io_device_throttle) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_block_io_device_throttle (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_block_io_device_throttle ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_block_io_device_throttle (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_block_io_device_throttle , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_device_cgroup { pub allow : bool , pub type_ : * mut :: std :: os :: raw :: c_char , pub major : i64 , pub minor : i64 , pub access : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_device_cgroup () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_device_cgroup > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_device_cgroup > () , 56usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_device_cgroup > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . allow) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup) , "::" , stringify ! (allow))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . major) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup) , "::" , stringify ! (major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . minor) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup) , "::" , stringify ! (minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . access) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup) , "::" , stringify ! (access))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_device_cgroup) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_device_cgroup { # [inline] pub fn allow_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_allow_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn major_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_major_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn minor_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_minor_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (allow_present : :: std :: os :: raw :: c_uint , major_present : :: std :: os :: raw :: c_uint , minor_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let allow_present : u32 = unsafe { :: std :: mem :: transmute (allow_present) } ; allow_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let major_present : u32 = unsafe { :: std :: mem :: transmute (major_present) } ; major_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let minor_present : u32 = unsafe { :: std :: mem :: transmute (minor_present) } ; minor_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_device_cgroup (ptr : * mut runtime_spec_schema_defs_linux_device_cgroup) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_device_cgroup (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_device_cgroup ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_device_cgroup (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_device_cgroup , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_network_interface_priority { pub name : * mut :: std :: os :: raw :: c_char , pub priority : u32 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_network_interface_priority () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_network_interface_priority > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_network_interface_priority > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_network_interface_priority))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_network_interface_priority > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_network_interface_priority))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . name) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_network_interface_priority) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . priority) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_network_interface_priority) , "::" , stringify ! (priority))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_network_interface_priority) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_network_interface_priority { # [inline] pub fn priority_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_priority_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (priority_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let priority_present : u32 = unsafe { :: std :: mem :: transmute (priority_present) } ; priority_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_network_interface_priority (ptr : * mut runtime_spec_schema_defs_linux_network_interface_priority) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_network_interface_priority (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_network_interface_priority ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_network_interface_priority (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_network_interface_priority , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_rdma { pub hca_handles : u32 , pub hca_objects : u32 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_rdma () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_rdma > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_rdma > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_rdma))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_rdma > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_rdma))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hca_handles) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_rdma) , "::" , stringify ! (hca_handles))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hca_objects) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_rdma) , "::" , stringify ! (hca_objects))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_rdma) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_rdma { # [inline] pub fn hca_handles_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_hca_handles_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn hca_objects_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_hca_objects_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (hca_handles_present : :: std :: os :: raw :: c_uint , hca_objects_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let hca_handles_present : u32 = unsafe { :: std :: mem :: transmute (hca_handles_present) } ; hca_handles_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let hca_objects_present : u32 = unsafe { :: std :: mem :: transmute (hca_objects_present) } ; hca_objects_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_rdma (ptr : * mut runtime_spec_schema_defs_linux_rdma) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_rdma (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_rdma ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_rdma (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_rdma , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_namespace_reference { pub type_ : * mut :: std :: os :: raw :: c_char , pub path : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_namespace_reference () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_namespace_reference > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_namespace_reference > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_namespace_reference))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_namespace_reference > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_namespace_reference))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_namespace_reference) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_namespace_reference) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_namespace_reference) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_defs_linux_namespace_reference (ptr : * mut runtime_spec_schema_defs_linux_namespace_reference) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_namespace_reference (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_namespace_reference ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_namespace_reference (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_namespace_reference , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_linux_time_offsets { pub secs : i64 , pub nanosecs : u32 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_linux_time_offsets () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_linux_time_offsets > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_linux_time_offsets > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_linux_time_offsets))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_linux_time_offsets > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_linux_time_offsets))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . secs) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_time_offsets) , "::" , stringify ! (secs))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . nanosecs) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_time_offsets) , "::" , stringify ! (nanosecs))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_linux_time_offsets) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_linux_time_offsets { # [inline] pub fn secs_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_secs_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn nanosecs_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_nanosecs_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (secs_present : :: std :: os :: raw :: c_uint , nanosecs_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let secs_present : u32 = unsafe { :: std :: mem :: transmute (secs_present) } ; secs_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let nanosecs_present : u32 = unsafe { :: std :: mem :: transmute (nanosecs_present) } ; nanosecs_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_linux_time_offsets (ptr : * mut runtime_spec_schema_defs_linux_time_offsets) ; } extern "C" { pub fn make_runtime_spec_schema_defs_linux_time_offsets (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_linux_time_offsets ; } extern "C" { pub fn gen_runtime_spec_schema_defs_linux_time_offsets (g : yajl_gen , ptr : * const runtime_spec_schema_defs_linux_time_offsets , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources_pids { pub limit : i64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources_pids () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources_pids > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources_pids > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources_pids))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources_pids > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources_pids))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . limit) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_pids) , "::" , stringify ! (limit))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_pids) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_linux_resources_pids { # [inline] pub fn limit_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_limit_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (limit_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let limit_present : u32 = unsafe { :: std :: mem :: transmute (limit_present) } ; limit_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources_pids (ptr : * mut runtime_spec_schema_config_linux_resources_pids) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources_pids (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources_pids ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_resources_pids (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_resources_pids , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources_block_io { pub weight : u16 , pub leaf_weight : u16 , pub throttle_read_bps_device : * mut * mut runtime_spec_schema_defs_linux_block_io_device_throttle , pub throttle_read_bps_device_len : usize , pub throttle_write_bps_device : * mut * mut runtime_spec_schema_defs_linux_block_io_device_throttle , pub throttle_write_bps_device_len : usize , pub throttle_read_iops_device : * mut * mut runtime_spec_schema_defs_linux_block_io_device_throttle , pub throttle_read_iops_device_len : usize , pub throttle_write_iops_device : * mut * mut runtime_spec_schema_defs_linux_block_io_device_throttle , pub throttle_write_iops_device_len : usize , pub weight_device : * mut * mut runtime_spec_schema_defs_linux_block_io_device_weight , pub weight_device_len : usize , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources_block_io () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources_block_io > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources_block_io > () , 104usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources_block_io > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources_block_io))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . weight) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (weight))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . leaf_weight) as usize - ptr as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (leaf_weight))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_read_bps_device) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_read_bps_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_read_bps_device_len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_read_bps_device_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_write_bps_device) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_write_bps_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_write_bps_device_len) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_write_bps_device_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_read_iops_device) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_read_iops_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_read_iops_device_len) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_read_iops_device_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_write_iops_device) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_write_iops_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . throttle_write_iops_device_len) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (throttle_write_iops_device_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . weight_device) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (weight_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . weight_device_len) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (weight_device_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_block_io) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_linux_resources_block_io { # [inline] pub fn weight_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_weight_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn leaf_weight_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_leaf_weight_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (weight_present : :: std :: os :: raw :: c_uint , leaf_weight_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let weight_present : u32 = unsafe { :: std :: mem :: transmute (weight_present) } ; weight_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let leaf_weight_present : u32 = unsafe { :: std :: mem :: transmute (leaf_weight_present) } ; leaf_weight_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources_block_io (ptr : * mut runtime_spec_schema_config_linux_resources_block_io) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources_block_io (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources_block_io ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_resources_block_io (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_resources_block_io , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources_cpu { pub cpus : * mut :: std :: os :: raw :: c_char , pub mems : * mut :: std :: os :: raw :: c_char , pub period : u64 , pub quota : i64 , pub burst : u64 , pub realtime_period : u64 , pub realtime_runtime : i64 , pub shares : u64 , pub idle : i64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources_cpu () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources_cpu > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources_cpu > () , 88usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources_cpu > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources_cpu))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cpus) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (cpus))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mems) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (mems))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . period) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (period))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . quota) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (quota))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . burst) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (burst))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . realtime_period) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (realtime_period))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . realtime_runtime) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (realtime_runtime))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . shares) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (shares))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . idle) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (idle))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_cpu) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_linux_resources_cpu { # [inline] pub fn period_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_period_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn quota_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_quota_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn burst_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_burst_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn realtime_period_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_realtime_period_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn realtime_runtime_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_realtime_runtime_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub fn shares_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (5usize , 1u8) as u32) } } # [inline] pub fn set_shares_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (5usize , 1u8 , val as u64) } } # [inline] pub fn idle_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (6usize , 1u8) as u32) } } # [inline] pub fn set_idle_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (6usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (period_present : :: std :: os :: raw :: c_uint , quota_present : :: std :: os :: raw :: c_uint , burst_present : :: std :: os :: raw :: c_uint , realtime_period_present : :: std :: os :: raw :: c_uint , realtime_runtime_present : :: std :: os :: raw :: c_uint , shares_present : :: std :: os :: raw :: c_uint , idle_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let period_present : u32 = unsafe { :: std :: mem :: transmute (period_present) } ; period_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let quota_present : u32 = unsafe { :: std :: mem :: transmute (quota_present) } ; quota_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let burst_present : u32 = unsafe { :: std :: mem :: transmute (burst_present) } ; burst_present as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let realtime_period_present : u32 = unsafe { :: std :: mem :: transmute (realtime_period_present) } ; realtime_period_present as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let realtime_runtime_present : u32 = unsafe { :: std :: mem :: transmute (realtime_runtime_present) } ; realtime_runtime_present as u64 }) ; __bindgen_bitfield_unit . set (5usize , 1u8 , { let shares_present : u32 = unsafe { :: std :: mem :: transmute (shares_present) } ; shares_present as u64 }) ; __bindgen_bitfield_unit . set (6usize , 1u8 , { let idle_present : u32 = unsafe { :: std :: mem :: transmute (idle_present) } ; idle_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources_cpu (ptr : * mut runtime_spec_schema_config_linux_resources_cpu) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources_cpu (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources_cpu ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_resources_cpu (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_resources_cpu , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources_hugepage_limits_element { pub page_size : * mut :: std :: os :: raw :: c_char , pub limit : u64 , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources_hugepage_limits_element () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources_hugepage_limits_element > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources_hugepage_limits_element > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources_hugepage_limits_element))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources_hugepage_limits_element > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources_hugepage_limits_element))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . page_size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_hugepage_limits_element) , "::" , stringify ! (page_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . limit) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_hugepage_limits_element) , "::" , stringify ! (limit))) ; } impl runtime_spec_schema_config_linux_resources_hugepage_limits_element { # [inline] pub fn limit_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_limit_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (limit_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let limit_present : u32 = unsafe { :: std :: mem :: transmute (limit_present) } ; limit_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources_hugepage_limits_element (ptr : * mut runtime_spec_schema_config_linux_resources_hugepage_limits_element) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources_hugepage_limits_element (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources_hugepage_limits_element ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources_memory { pub kernel : i64 , pub kernel_tcp : i64 , pub limit : i64 , pub reservation : i64 , pub swap : i64 , pub swappiness : u64 , pub disable_oom_killer : bool , pub use_hierarchy : bool , pub check_before_update : bool , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 2usize] > , pub __bindgen_padding_0 : [u16 ; 3usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources_memory () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources_memory > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources_memory > () , 72usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources_memory))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources_memory > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources_memory))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . kernel) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (kernel))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . kernel_tcp) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (kernel_tcp))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . limit) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (limit))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . reservation) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (reservation))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . swap) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (swap))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . swappiness) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (swappiness))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . disable_oom_killer) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (disable_oom_killer))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . use_hierarchy) as usize - ptr as usize } , 49usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (use_hierarchy))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . check_before_update) as usize - ptr as usize } , 50usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (check_before_update))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_memory) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_linux_resources_memory { # [inline] pub fn kernel_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_kernel_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn kernel_tcp_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_kernel_tcp_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn limit_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_limit_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn reservation_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_reservation_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn swap_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_swap_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub fn swappiness_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (5usize , 1u8) as u32) } } # [inline] pub fn set_swappiness_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (5usize , 1u8 , val as u64) } } # [inline] pub fn disable_oom_killer_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (6usize , 1u8) as u32) } } # [inline] pub fn set_disable_oom_killer_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (6usize , 1u8 , val as u64) } } # [inline] pub fn use_hierarchy_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (7usize , 1u8) as u32) } } # [inline] pub fn set_use_hierarchy_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (7usize , 1u8 , val as u64) } } # [inline] pub fn check_before_update_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (8usize , 1u8) as u32) } } # [inline] pub fn set_check_before_update_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (8usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (kernel_present : :: std :: os :: raw :: c_uint , kernel_tcp_present : :: std :: os :: raw :: c_uint , limit_present : :: std :: os :: raw :: c_uint , reservation_present : :: std :: os :: raw :: c_uint , swap_present : :: std :: os :: raw :: c_uint , swappiness_present : :: std :: os :: raw :: c_uint , disable_oom_killer_present : :: std :: os :: raw :: c_uint , use_hierarchy_present : :: std :: os :: raw :: c_uint , check_before_update_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 2usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 2usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let kernel_present : u32 = unsafe { :: std :: mem :: transmute (kernel_present) } ; kernel_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let kernel_tcp_present : u32 = unsafe { :: std :: mem :: transmute (kernel_tcp_present) } ; kernel_tcp_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let limit_present : u32 = unsafe { :: std :: mem :: transmute (limit_present) } ; limit_present as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let reservation_present : u32 = unsafe { :: std :: mem :: transmute (reservation_present) } ; reservation_present as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let swap_present : u32 = unsafe { :: std :: mem :: transmute (swap_present) } ; swap_present as u64 }) ; __bindgen_bitfield_unit . set (5usize , 1u8 , { let swappiness_present : u32 = unsafe { :: std :: mem :: transmute (swappiness_present) } ; swappiness_present as u64 }) ; __bindgen_bitfield_unit . set (6usize , 1u8 , { let disable_oom_killer_present : u32 = unsafe { :: std :: mem :: transmute (disable_oom_killer_present) } ; disable_oom_killer_present as u64 }) ; __bindgen_bitfield_unit . set (7usize , 1u8 , { let use_hierarchy_present : u32 = unsafe { :: std :: mem :: transmute (use_hierarchy_present) } ; use_hierarchy_present as u64 }) ; __bindgen_bitfield_unit . set (8usize , 1u8 , { let check_before_update_present : u32 = unsafe { :: std :: mem :: transmute (check_before_update_present) } ; check_before_update_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources_memory (ptr : * mut runtime_spec_schema_config_linux_resources_memory) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources_memory (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources_memory ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_resources_memory (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_resources_memory , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources_network { pub class_id : u32 , pub priorities : * mut * mut runtime_spec_schema_defs_linux_network_interface_priority , pub priorities_len : usize , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources_network () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources_network > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources_network > () , 40usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources_network))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources_network > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources_network))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . class_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_network) , "::" , stringify ! (class_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . priorities) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_network) , "::" , stringify ! (priorities))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . priorities_len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_network) , "::" , stringify ! (priorities_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_network) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_linux_resources_network { # [inline] pub fn class_id_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_class_id_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (class_id_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let class_id_present : u32 = unsafe { :: std :: mem :: transmute (class_id_present) } ; class_id_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources_network (ptr : * mut runtime_spec_schema_config_linux_resources_network) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources_network (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources_network ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_resources_network (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_resources_network , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources_rdma { pub unuseful : :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources_rdma () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources_rdma > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources_rdma > () , 1usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources_rdma))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources_rdma > () , 1usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources_rdma))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . unuseful) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources_rdma) , "::" , stringify ! (unuseful))) ; } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources_rdma (ptr : * mut runtime_spec_schema_config_linux_resources_rdma) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources_rdma (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources_rdma ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_resources_rdma (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_resources_rdma , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_resources { pub unified : * mut json_map_string_string , pub devices : * mut * mut runtime_spec_schema_defs_linux_device_cgroup , pub devices_len : usize , pub pids : * mut runtime_spec_schema_config_linux_resources_pids , pub block_io : * mut runtime_spec_schema_config_linux_resources_block_io , pub cpu : * mut runtime_spec_schema_config_linux_resources_cpu , pub hugepage_limits : * mut * mut runtime_spec_schema_config_linux_resources_hugepage_limits_element , pub hugepage_limits_len : usize , pub memory : * mut runtime_spec_schema_config_linux_resources_memory , pub network : * mut runtime_spec_schema_config_linux_resources_network , pub rdma : * mut runtime_spec_schema_config_linux_resources_rdma , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_resources () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_resources > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_resources > () , 96usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_resources))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_resources > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_resources))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . unified) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (unified))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (devices))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices_len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (devices_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . pids) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (pids))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . block_io) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (block_io))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cpu) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (cpu))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hugepage_limits) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (hugepage_limits))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hugepage_limits_len) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (hugepage_limits_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . memory) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (memory))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . network) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (network))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rdma) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (rdma))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_resources) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_linux_resources (ptr : * mut runtime_spec_schema_config_linux_resources) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_resources (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_resources ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_resources (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_resources , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_seccomp { pub default_action : * mut :: std :: os :: raw :: c_char , pub default_errno_ret : u32 , pub flags : * mut * mut :: std :: os :: raw :: c_char , pub flags_len : usize , pub listener_path : * mut :: std :: os :: raw :: c_char , pub listener_metadata : * mut :: std :: os :: raw :: c_char , pub architectures : * mut * mut :: std :: os :: raw :: c_char , pub architectures_len : usize , pub syscalls : * mut * mut runtime_spec_schema_defs_linux_syscall , pub syscalls_len : usize , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_seccomp () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_seccomp > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_seccomp > () , 96usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_seccomp))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_seccomp > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_seccomp))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . default_action) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (default_action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . default_errno_ret) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (default_errno_ret))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . flags) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . flags_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (flags_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . listener_path) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (listener_path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . listener_metadata) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (listener_metadata))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . architectures) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (architectures))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . architectures_len) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (architectures_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . syscalls) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (syscalls))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . syscalls_len) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (syscalls_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_seccomp) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_linux_seccomp { # [inline] pub fn default_errno_ret_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_default_errno_ret_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (default_errno_ret_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let default_errno_ret_present : u32 = unsafe { :: std :: mem :: transmute (default_errno_ret_present) } ; default_errno_ret_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_seccomp (ptr : * mut runtime_spec_schema_config_linux_seccomp) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_seccomp (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_seccomp ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_seccomp (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_seccomp , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_intel_rdt { pub clos_id : * mut :: std :: os :: raw :: c_char , pub l3cache_schema : * mut :: std :: os :: raw :: c_char , pub mem_bw_schema : * mut :: std :: os :: raw :: c_char , pub enable_cmt : bool , pub enable_mbm : bool , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_intel_rdt () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_intel_rdt > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_intel_rdt > () , 48usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_intel_rdt))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_intel_rdt > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_intel_rdt))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . clos_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_intel_rdt) , "::" , stringify ! (clos_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . l3cache_schema) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_intel_rdt) , "::" , stringify ! (l3cache_schema))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_bw_schema) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_intel_rdt) , "::" , stringify ! (mem_bw_schema))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . enable_cmt) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_intel_rdt) , "::" , stringify ! (enable_cmt))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . enable_mbm) as usize - ptr as usize } , 25usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_intel_rdt) , "::" , stringify ! (enable_mbm))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_intel_rdt) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_linux_intel_rdt { # [inline] pub fn enable_cmt_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_enable_cmt_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn enable_mbm_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_enable_mbm_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (enable_cmt_present : :: std :: os :: raw :: c_uint , enable_mbm_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let enable_cmt_present : u32 = unsafe { :: std :: mem :: transmute (enable_cmt_present) } ; enable_cmt_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let enable_mbm_present : u32 = unsafe { :: std :: mem :: transmute (enable_mbm_present) } ; enable_mbm_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_linux_intel_rdt (ptr : * mut runtime_spec_schema_config_linux_intel_rdt) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_intel_rdt (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_intel_rdt ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_intel_rdt (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_intel_rdt , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux_time_offsets { pub boottime : * mut runtime_spec_schema_defs_linux_time_offsets , pub monotonic : * mut runtime_spec_schema_defs_linux_time_offsets , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux_time_offsets () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux_time_offsets > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux_time_offsets > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux_time_offsets))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux_time_offsets > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux_time_offsets))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . boottime) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_time_offsets) , "::" , stringify ! (boottime))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . monotonic) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_time_offsets) , "::" , stringify ! (monotonic))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux_time_offsets) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_linux_time_offsets (ptr : * mut runtime_spec_schema_config_linux_time_offsets) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux_time_offsets (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux_time_offsets ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux_time_offsets (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux_time_offsets , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_linux { pub devices : * mut * mut runtime_spec_schema_defs_linux_device , pub devices_len : usize , pub uid_mappings : * mut * mut runtime_spec_schema_defs_id_mapping , pub uid_mappings_len : usize , pub gid_mappings : * mut * mut runtime_spec_schema_defs_id_mapping , pub gid_mappings_len : usize , pub namespaces : * mut * mut runtime_spec_schema_defs_linux_namespace_reference , pub namespaces_len : usize , pub resources : * mut runtime_spec_schema_config_linux_resources , pub cgroups_path : * mut :: std :: os :: raw :: c_char , pub rootfs_propagation : * mut :: std :: os :: raw :: c_char , pub seccomp : * mut runtime_spec_schema_config_linux_seccomp , pub sysctl : * mut json_map_string_string , pub masked_paths : * mut * mut :: std :: os :: raw :: c_char , pub masked_paths_len : usize , pub readonly_paths : * mut * mut :: std :: os :: raw :: c_char , pub readonly_paths_len : usize , pub mount_label : * mut :: std :: os :: raw :: c_char , pub intel_rdt : * mut runtime_spec_schema_config_linux_intel_rdt , pub personality : * mut runtime_spec_schema_defs_linux_personality , pub time_offsets : * mut runtime_spec_schema_config_linux_time_offsets , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_linux () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_linux > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_linux > () , 176usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_linux))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_linux > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_linux))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (devices))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (devices_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . uid_mappings) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (uid_mappings))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . uid_mappings_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (uid_mappings_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gid_mappings) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (gid_mappings))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gid_mappings_len) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (gid_mappings_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . namespaces) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (namespaces))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . namespaces_len) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (namespaces_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . resources) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (resources))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cgroups_path) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (cgroups_path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rootfs_propagation) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (rootfs_propagation))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . seccomp) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (seccomp))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . sysctl) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (sysctl))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . masked_paths) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (masked_paths))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . masked_paths_len) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (masked_paths_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . readonly_paths) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (readonly_paths))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . readonly_paths_len) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (readonly_paths_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mount_label) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (mount_label))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . intel_rdt) as usize - ptr as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (intel_rdt))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . personality) as usize - ptr as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (personality))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . time_offsets) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (time_offsets))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_linux) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_linux (ptr : * mut runtime_spec_schema_config_linux) ; } extern "C" { pub fn make_runtime_spec_schema_config_linux (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_linux ; } extern "C" { pub fn gen_runtime_spec_schema_config_linux (g : yajl_gen , ptr : * const runtime_spec_schema_config_linux , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_solaris_capped_cpu { pub ncpus : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_solaris_capped_cpu () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_solaris_capped_cpu > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_solaris_capped_cpu > () , 16usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_solaris_capped_cpu))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_solaris_capped_cpu > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_solaris_capped_cpu))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ncpus) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_capped_cpu) , "::" , stringify ! (ncpus))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_capped_cpu) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_solaris_capped_cpu (ptr : * mut runtime_spec_schema_config_solaris_capped_cpu) ; } extern "C" { pub fn make_runtime_spec_schema_config_solaris_capped_cpu (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_solaris_capped_cpu ; } extern "C" { pub fn gen_runtime_spec_schema_config_solaris_capped_cpu (g : yajl_gen , ptr : * const runtime_spec_schema_config_solaris_capped_cpu , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_solaris_capped_memory { pub physical : * mut :: std :: os :: raw :: c_char , pub swap : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_solaris_capped_memory () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_solaris_capped_memory > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_solaris_capped_memory > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_solaris_capped_memory))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_solaris_capped_memory > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_solaris_capped_memory))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . physical) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_capped_memory) , "::" , stringify ! (physical))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . swap) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_capped_memory) , "::" , stringify ! (swap))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_capped_memory) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_solaris_capped_memory (ptr : * mut runtime_spec_schema_config_solaris_capped_memory) ; } extern "C" { pub fn make_runtime_spec_schema_config_solaris_capped_memory (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_solaris_capped_memory ; } extern "C" { pub fn gen_runtime_spec_schema_config_solaris_capped_memory (g : yajl_gen , ptr : * const runtime_spec_schema_config_solaris_capped_memory , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_solaris_anet_element { pub linkname : * mut :: std :: os :: raw :: c_char , pub lower_link : * mut :: std :: os :: raw :: c_char , pub allowed_address : * mut :: std :: os :: raw :: c_char , pub configure_allowed_address : * mut :: std :: os :: raw :: c_char , pub defrouter : * mut :: std :: os :: raw :: c_char , pub mac_address : * mut :: std :: os :: raw :: c_char , pub link_protection : * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_solaris_anet_element () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_solaris_anet_element > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_solaris_anet_element > () , 56usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_solaris_anet_element))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_solaris_anet_element > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_solaris_anet_element))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . linkname) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_anet_element) , "::" , stringify ! (linkname))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . lower_link) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_anet_element) , "::" , stringify ! (lower_link))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . allowed_address) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_anet_element) , "::" , stringify ! (allowed_address))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . configure_allowed_address) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_anet_element) , "::" , stringify ! (configure_allowed_address))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . defrouter) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_anet_element) , "::" , stringify ! (defrouter))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mac_address) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_anet_element) , "::" , stringify ! (mac_address))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . link_protection) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris_anet_element) , "::" , stringify ! (link_protection))) ; } extern "C" { pub fn free_runtime_spec_schema_config_solaris_anet_element (ptr : * mut runtime_spec_schema_config_solaris_anet_element) ; } extern "C" { pub fn make_runtime_spec_schema_config_solaris_anet_element (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_solaris_anet_element ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_solaris { pub milestone : * mut :: std :: os :: raw :: c_char , pub limitpriv : * mut :: std :: os :: raw :: c_char , pub max_shm_memory : * mut :: std :: os :: raw :: c_char , pub capped_cpu : * mut runtime_spec_schema_config_solaris_capped_cpu , pub capped_memory : * mut runtime_spec_schema_config_solaris_capped_memory , pub anet : * mut * mut runtime_spec_schema_config_solaris_anet_element , pub anet_len : usize , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_solaris () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_solaris > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_solaris > () , 64usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_solaris))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_solaris > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_solaris))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . milestone) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (milestone))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . limitpriv) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (limitpriv))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . max_shm_memory) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (max_shm_memory))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . capped_cpu) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (capped_cpu))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . capped_memory) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (capped_memory))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . anet) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (anet))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . anet_len) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (anet_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_solaris) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_solaris (ptr : * mut runtime_spec_schema_config_solaris) ; } extern "C" { pub fn make_runtime_spec_schema_config_solaris (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_solaris ; } extern "C" { pub fn gen_runtime_spec_schema_config_solaris (g : yajl_gen , ptr : * const runtime_spec_schema_config_solaris , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_windows_device { pub id : * mut :: std :: os :: raw :: c_char , pub id_type : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_windows_device () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_windows_device > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_windows_device > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_windows_device))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_windows_device > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_windows_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_windows_device) , "::" , stringify ! (id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . id_type) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_windows_device) , "::" , stringify ! (id_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_windows_device) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_defs_windows_device (ptr : * mut runtime_spec_schema_defs_windows_device) ; } extern "C" { pub fn make_runtime_spec_schema_defs_windows_device (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_windows_device ; } extern "C" { pub fn gen_runtime_spec_schema_defs_windows_device (g : yajl_gen , ptr : * const runtime_spec_schema_defs_windows_device , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows_resources_memory { pub limit : u64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows_resources_memory () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows_resources_memory > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows_resources_memory > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows_resources_memory))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows_resources_memory > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows_resources_memory))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . limit) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_memory) , "::" , stringify ! (limit))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_memory) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_windows_resources_memory { # [inline] pub fn limit_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_limit_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (limit_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let limit_present : u32 = unsafe { :: std :: mem :: transmute (limit_present) } ; limit_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_windows_resources_memory (ptr : * mut runtime_spec_schema_config_windows_resources_memory) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows_resources_memory (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows_resources_memory ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows_resources_memory (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows_resources_memory , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows_resources_cpu { pub count : u64 , pub shares : u16 , pub maximum : u16 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows_resources_cpu () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows_resources_cpu > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows_resources_cpu > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows_resources_cpu))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows_resources_cpu > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows_resources_cpu))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . count) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_cpu) , "::" , stringify ! (count))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . shares) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_cpu) , "::" , stringify ! (shares))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . maximum) as usize - ptr as usize } , 10usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_cpu) , "::" , stringify ! (maximum))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_cpu) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_windows_resources_cpu { # [inline] pub fn count_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_count_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn shares_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_shares_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn maximum_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_maximum_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (count_present : :: std :: os :: raw :: c_uint , shares_present : :: std :: os :: raw :: c_uint , maximum_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let count_present : u32 = unsafe { :: std :: mem :: transmute (count_present) } ; count_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let shares_present : u32 = unsafe { :: std :: mem :: transmute (shares_present) } ; shares_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let maximum_present : u32 = unsafe { :: std :: mem :: transmute (maximum_present) } ; maximum_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_windows_resources_cpu (ptr : * mut runtime_spec_schema_config_windows_resources_cpu) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows_resources_cpu (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows_resources_cpu ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows_resources_cpu (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows_resources_cpu , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows_resources_storage { pub iops : u64 , pub bps : u64 , pub sandbox_size : u64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows_resources_storage () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows_resources_storage > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows_resources_storage > () , 40usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows_resources_storage))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows_resources_storage > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows_resources_storage))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . iops) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_storage) , "::" , stringify ! (iops))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . bps) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_storage) , "::" , stringify ! (bps))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . sandbox_size) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_storage) , "::" , stringify ! (sandbox_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources_storage) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_windows_resources_storage { # [inline] pub fn iops_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_iops_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn bps_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_bps_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn sandbox_size_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_sandbox_size_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (iops_present : :: std :: os :: raw :: c_uint , bps_present : :: std :: os :: raw :: c_uint , sandbox_size_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let iops_present : u32 = unsafe { :: std :: mem :: transmute (iops_present) } ; iops_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let bps_present : u32 = unsafe { :: std :: mem :: transmute (bps_present) } ; bps_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let sandbox_size_present : u32 = unsafe { :: std :: mem :: transmute (sandbox_size_present) } ; sandbox_size_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_windows_resources_storage (ptr : * mut runtime_spec_schema_config_windows_resources_storage) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows_resources_storage (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows_resources_storage ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows_resources_storage (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows_resources_storage , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows_resources { pub memory : * mut runtime_spec_schema_config_windows_resources_memory , pub cpu : * mut runtime_spec_schema_config_windows_resources_cpu , pub storage : * mut runtime_spec_schema_config_windows_resources_storage , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows_resources () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows_resources > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows_resources > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows_resources))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows_resources > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows_resources))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . memory) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources) , "::" , stringify ! (memory))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cpu) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources) , "::" , stringify ! (cpu))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . storage) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources) , "::" , stringify ! (storage))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_resources) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_windows_resources (ptr : * mut runtime_spec_schema_config_windows_resources) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows_resources (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows_resources ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows_resources (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows_resources , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows_network { pub endpoint_list : * mut * mut :: std :: os :: raw :: c_char , pub endpoint_list_len : usize , pub allow_unqualified_dns_query : bool , pub dns_search_list : * mut * mut :: std :: os :: raw :: c_char , pub dns_search_list_len : usize , pub network_shared_container_name : * mut :: std :: os :: raw :: c_char , pub network_namespace : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows_network () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows_network > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows_network > () , 72usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows_network))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows_network > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows_network))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . endpoint_list) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (endpoint_list))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . endpoint_list_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (endpoint_list_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . allow_unqualified_dns_query) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (allow_unqualified_dns_query))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . dns_search_list) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (dns_search_list))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . dns_search_list_len) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (dns_search_list_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . network_shared_container_name) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (network_shared_container_name))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . network_namespace) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (network_namespace))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_network) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_windows_network { # [inline] pub fn allow_unqualified_dns_query_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_allow_unqualified_dns_query_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (allow_unqualified_dns_query_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let allow_unqualified_dns_query_present : u32 = unsafe { :: std :: mem :: transmute (allow_unqualified_dns_query_present) } ; allow_unqualified_dns_query_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_windows_network (ptr : * mut runtime_spec_schema_config_windows_network) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows_network (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows_network ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows_network (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows_network , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows_credential_spec { pub unuseful : :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows_credential_spec () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows_credential_spec > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows_credential_spec > () , 1usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows_credential_spec))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows_credential_spec > () , 1usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows_credential_spec))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . unuseful) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_credential_spec) , "::" , stringify ! (unuseful))) ; } extern "C" { pub fn free_runtime_spec_schema_config_windows_credential_spec (ptr : * mut runtime_spec_schema_config_windows_credential_spec) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows_credential_spec (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows_credential_spec ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows_credential_spec (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows_credential_spec , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows_hyperv { pub utility_vm_path : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows_hyperv () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows_hyperv > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows_hyperv > () , 16usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows_hyperv))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows_hyperv > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows_hyperv))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . utility_vm_path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_hyperv) , "::" , stringify ! (utility_vm_path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows_hyperv) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_windows_hyperv (ptr : * mut runtime_spec_schema_config_windows_hyperv) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows_hyperv (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows_hyperv ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows_hyperv (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows_hyperv , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_windows { pub layer_folders : * mut * mut :: std :: os :: raw :: c_char , pub layer_folders_len : usize , pub devices : * mut * mut runtime_spec_schema_defs_windows_device , pub devices_len : usize , pub resources : * mut runtime_spec_schema_config_windows_resources , pub network : * mut runtime_spec_schema_config_windows_network , pub credential_spec : * mut runtime_spec_schema_config_windows_credential_spec , pub servicing : bool , pub ignore_flushes_during_boot : bool , pub hyperv : * mut runtime_spec_schema_config_windows_hyperv , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_windows () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_windows > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_windows > () , 88usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_windows))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_windows > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_windows))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . layer_folders) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (layer_folders))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . layer_folders_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (layer_folders_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (devices))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (devices_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . resources) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (resources))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . network) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (network))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . credential_spec) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (credential_spec))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . servicing) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (servicing))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ignore_flushes_during_boot) as usize - ptr as usize } , 57usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (ignore_flushes_during_boot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hyperv) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (hyperv))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_windows) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_windows { # [inline] pub fn servicing_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_servicing_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn ignore_flushes_during_boot_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_ignore_flushes_during_boot_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (servicing_present : :: std :: os :: raw :: c_uint , ignore_flushes_during_boot_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let servicing_present : u32 = unsafe { :: std :: mem :: transmute (servicing_present) } ; servicing_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let ignore_flushes_during_boot_present : u32 = unsafe { :: std :: mem :: transmute (ignore_flushes_during_boot_present) } ; ignore_flushes_during_boot_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_windows (ptr : * mut runtime_spec_schema_config_windows) ; } extern "C" { pub fn make_runtime_spec_schema_config_windows (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_windows ; } extern "C" { pub fn gen_runtime_spec_schema_config_windows (g : yajl_gen , ptr : * const runtime_spec_schema_config_windows , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_vm_hypervisor { pub path : * mut :: std :: os :: raw :: c_char , pub parameters : * mut * mut :: std :: os :: raw :: c_char , pub parameters_len : usize , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_vm_hypervisor () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_vm_hypervisor > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_vm_hypervisor > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_vm_hypervisor))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_vm_hypervisor > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_vm_hypervisor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_hypervisor) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . parameters) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_hypervisor) , "::" , stringify ! (parameters))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . parameters_len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_hypervisor) , "::" , stringify ! (parameters_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_hypervisor) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_vm_hypervisor (ptr : * mut runtime_spec_schema_config_vm_hypervisor) ; } extern "C" { pub fn make_runtime_spec_schema_config_vm_hypervisor (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_vm_hypervisor ; } extern "C" { pub fn gen_runtime_spec_schema_config_vm_hypervisor (g : yajl_gen , ptr : * const runtime_spec_schema_config_vm_hypervisor , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_vm_kernel { pub path : * mut :: std :: os :: raw :: c_char , pub parameters : * mut * mut :: std :: os :: raw :: c_char , pub parameters_len : usize , pub initrd : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_vm_kernel () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_vm_kernel > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_vm_kernel > () , 40usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_vm_kernel))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_vm_kernel > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_vm_kernel))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_kernel) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . parameters) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_kernel) , "::" , stringify ! (parameters))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . parameters_len) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_kernel) , "::" , stringify ! (parameters_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . initrd) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_kernel) , "::" , stringify ! (initrd))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_kernel) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_vm_kernel (ptr : * mut runtime_spec_schema_config_vm_kernel) ; } extern "C" { pub fn make_runtime_spec_schema_config_vm_kernel (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_vm_kernel ; } extern "C" { pub fn gen_runtime_spec_schema_config_vm_kernel (g : yajl_gen , ptr : * const runtime_spec_schema_config_vm_kernel , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_vm_image { pub path : * mut :: std :: os :: raw :: c_char , pub format : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_vm_image () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_vm_image > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_vm_image > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_vm_image))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_vm_image > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_vm_image))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_image) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . format) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_image) , "::" , stringify ! (format))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm_image) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_vm_image (ptr : * mut runtime_spec_schema_config_vm_image) ; } extern "C" { pub fn make_runtime_spec_schema_config_vm_image (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_vm_image ; } extern "C" { pub fn gen_runtime_spec_schema_config_vm_image (g : yajl_gen , ptr : * const runtime_spec_schema_config_vm_image , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_vm { pub hypervisor : * mut runtime_spec_schema_config_vm_hypervisor , pub kernel : * mut runtime_spec_schema_config_vm_kernel , pub image : * mut runtime_spec_schema_config_vm_image , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_vm () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_vm > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_vm > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_vm))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_vm > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_vm))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hypervisor) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm) , "::" , stringify ! (hypervisor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . kernel) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm) , "::" , stringify ! (kernel))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . image) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm) , "::" , stringify ! (image))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_vm) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_vm (ptr : * mut runtime_spec_schema_config_vm) ; } extern "C" { pub fn make_runtime_spec_schema_config_vm (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_vm ; } extern "C" { pub fn gen_runtime_spec_schema_config_vm (g : yajl_gen , ptr : * const runtime_spec_schema_config_vm , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_defs_zos_device { pub path : * mut :: std :: os :: raw :: c_char , pub type_ : * mut :: std :: os :: raw :: c_char , pub major : i64 , pub minor : i64 , pub file_mode : :: std :: os :: raw :: c_int , pub uid : uid_t , pub gid : gid_t , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_defs_zos_device () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_defs_zos_device > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_defs_zos_device > () , 64usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_defs_zos_device))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_defs_zos_device > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_defs_zos_device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . major) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . minor) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . file_mode) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (file_mode))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . uid) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (uid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gid) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (gid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_defs_zos_device) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_defs_zos_device { # [inline] pub fn major_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_major_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn minor_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_minor_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn file_mode_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_file_mode_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn uid_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_uid_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn gid_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_gid_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (major_present : :: std :: os :: raw :: c_uint , minor_present : :: std :: os :: raw :: c_uint , file_mode_present : :: std :: os :: raw :: c_uint , uid_present : :: std :: os :: raw :: c_uint , gid_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let major_present : u32 = unsafe { :: std :: mem :: transmute (major_present) } ; major_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let minor_present : u32 = unsafe { :: std :: mem :: transmute (minor_present) } ; minor_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let file_mode_present : u32 = unsafe { :: std :: mem :: transmute (file_mode_present) } ; file_mode_present as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let uid_present : u32 = unsafe { :: std :: mem :: transmute (uid_present) } ; uid_present as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let gid_present : u32 = unsafe { :: std :: mem :: transmute (gid_present) } ; gid_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_defs_zos_device (ptr : * mut runtime_spec_schema_defs_zos_device) ; } extern "C" { pub fn make_runtime_spec_schema_defs_zos_device (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_defs_zos_device ; } extern "C" { pub fn gen_runtime_spec_schema_defs_zos_device (g : yajl_gen , ptr : * const runtime_spec_schema_defs_zos_device , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_zos { pub devices : * mut * mut runtime_spec_schema_defs_zos_device , pub devices_len : usize , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_zos () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_zos > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_zos > () , 24usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_zos))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_zos > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_zos))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_zos) , "::" , stringify ! (devices))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . devices_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_zos) , "::" , stringify ! (devices_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_zos) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_zos (ptr : * mut runtime_spec_schema_config_zos) ; } extern "C" { pub fn make_runtime_spec_schema_config_zos (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_zos ; } extern "C" { pub fn gen_runtime_spec_schema_config_zos (g : yajl_gen , ptr : * const runtime_spec_schema_config_zos , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_hooks { pub prestart : * mut * mut runtime_spec_schema_defs_hook , pub prestart_len : usize , pub create_runtime : * mut * mut runtime_spec_schema_defs_hook , pub create_runtime_len : usize , pub create_container : * mut * mut runtime_spec_schema_defs_hook , pub create_container_len : usize , pub start_container : * mut * mut runtime_spec_schema_defs_hook , pub start_container_len : usize , pub poststart : * mut * mut runtime_spec_schema_defs_hook , pub poststart_len : usize , pub poststop : * mut * mut runtime_spec_schema_defs_hook , pub poststop_len : usize , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_hooks () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_hooks > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_hooks > () , 104usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_hooks))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_hooks > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_hooks))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . prestart) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (prestart))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . prestart_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (prestart_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . create_runtime) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (create_runtime))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . create_runtime_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (create_runtime_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . create_container) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (create_container))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . create_container_len) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (create_container_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . start_container) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (start_container))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . start_container_len) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (start_container_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . poststart) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (poststart))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . poststart_len) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (poststart_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . poststop) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (poststop))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . poststop_len) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (poststop_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_hooks) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_schema_hooks (ptr : * mut runtime_spec_schema_config_schema_hooks) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_hooks (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_hooks ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_hooks (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_hooks , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_root { pub path : * mut :: std :: os :: raw :: c_char , pub readonly : bool , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_root () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_root > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_root > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_root))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_root > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_root))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_root) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . readonly) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_root) , "::" , stringify ! (readonly))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_root) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_schema_root { # [inline] pub fn readonly_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_readonly_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (readonly_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let readonly_present : u32 = unsafe { :: std :: mem :: transmute (readonly_present) } ; readonly_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_schema_root (ptr : * mut runtime_spec_schema_config_schema_root) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_root (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_root ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_root (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_root , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_process_console_size { pub height : u64 , pub width : u64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_process_console_size () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_process_console_size > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_process_console_size > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_process_console_size))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_process_console_size > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_process_console_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . height) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_console_size) , "::" , stringify ! (height))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . width) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_console_size) , "::" , stringify ! (width))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_console_size) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_schema_process_console_size { # [inline] pub fn height_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_height_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn width_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_width_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (height_present : :: std :: os :: raw :: c_uint , width_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let height_present : u32 = unsafe { :: std :: mem :: transmute (height_present) } ; height_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let width_present : u32 = unsafe { :: std :: mem :: transmute (width_present) } ; width_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_schema_process_console_size (ptr : * mut runtime_spec_schema_config_schema_process_console_size) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_process_console_size (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_process_console_size ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_process_console_size (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_process_console_size , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_process_user { pub uid : uid_t , pub gid : gid_t , pub umask : u32 , pub additional_gids : * mut gid_t , pub additional_gids_len : usize , pub username : * mut :: std :: os :: raw :: c_char , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_process_user () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_process_user > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_process_user > () , 56usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_process_user))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_process_user > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_process_user))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . uid) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_user) , "::" , stringify ! (uid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gid) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_user) , "::" , stringify ! (gid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . umask) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_user) , "::" , stringify ! (umask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . additional_gids) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_user) , "::" , stringify ! (additional_gids))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . additional_gids_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_user) , "::" , stringify ! (additional_gids_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . username) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_user) , "::" , stringify ! (username))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_user) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_schema_process_user { # [inline] pub fn uid_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_uid_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn gid_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_gid_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn umask_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_umask_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (uid_present : :: std :: os :: raw :: c_uint , gid_present : :: std :: os :: raw :: c_uint , umask_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let uid_present : u32 = unsafe { :: std :: mem :: transmute (uid_present) } ; uid_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let gid_present : u32 = unsafe { :: std :: mem :: transmute (gid_present) } ; gid_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let umask_present : u32 = unsafe { :: std :: mem :: transmute (umask_present) } ; umask_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_schema_process_user (ptr : * mut runtime_spec_schema_config_schema_process_user) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_process_user (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_process_user ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_process_user (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_process_user , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_process_capabilities { pub bounding : * mut * mut :: std :: os :: raw :: c_char , pub bounding_len : usize , pub permitted : * mut * mut :: std :: os :: raw :: c_char , pub permitted_len : usize , pub effective : * mut * mut :: std :: os :: raw :: c_char , pub effective_len : usize , pub inheritable : * mut * mut :: std :: os :: raw :: c_char , pub inheritable_len : usize , pub ambient : * mut * mut :: std :: os :: raw :: c_char , pub ambient_len : usize , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_process_capabilities () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_process_capabilities > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_process_capabilities > () , 88usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_process_capabilities > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_process_capabilities))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . bounding) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (bounding))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . bounding_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (bounding_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . permitted) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (permitted))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . permitted_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (permitted_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . effective) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (effective))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . effective_len) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (effective_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . inheritable) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (inheritable))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . inheritable_len) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (inheritable_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ambient) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (ambient))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ambient_len) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (ambient_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_capabilities) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_schema_process_capabilities (ptr : * mut runtime_spec_schema_config_schema_process_capabilities) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_process_capabilities (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_process_capabilities ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_process_capabilities (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_process_capabilities , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_process_io_priority { pub _class : * mut :: std :: os :: raw :: c_char , pub priority : i32 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_process_io_priority () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_process_io_priority > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_process_io_priority > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_process_io_priority))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_process_io_priority > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_process_io_priority))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _class) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_io_priority) , "::" , stringify ! (_class))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . priority) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_io_priority) , "::" , stringify ! (priority))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_io_priority) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_schema_process_io_priority { # [inline] pub fn priority_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_priority_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (priority_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let priority_present : u32 = unsafe { :: std :: mem :: transmute (priority_present) } ; priority_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_schema_process_io_priority (ptr : * mut runtime_spec_schema_config_schema_process_io_priority) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_process_io_priority (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_process_io_priority ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_process_io_priority (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_process_io_priority , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_process_scheduler { pub policy : * mut :: std :: os :: raw :: c_char , pub nice : i32 , pub priority : i32 , pub flags : * mut * mut :: std :: os :: raw :: c_char , pub flags_len : usize , pub runtime : u64 , pub deadline : u64 , pub period : u64 , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_process_scheduler () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_process_scheduler > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_process_scheduler > () , 72usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_process_scheduler > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_process_scheduler))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . policy) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (policy))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . nice) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (nice))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . priority) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (priority))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . flags) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . flags_len) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (flags_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . runtime) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (runtime))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . deadline) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (deadline))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . period) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (period))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_scheduler) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_schema_process_scheduler { # [inline] pub fn nice_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_nice_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn priority_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_priority_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn runtime_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_runtime_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn deadline_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_deadline_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn period_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_period_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (nice_present : :: std :: os :: raw :: c_uint , priority_present : :: std :: os :: raw :: c_uint , runtime_present : :: std :: os :: raw :: c_uint , deadline_present : :: std :: os :: raw :: c_uint , period_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let nice_present : u32 = unsafe { :: std :: mem :: transmute (nice_present) } ; nice_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let priority_present : u32 = unsafe { :: std :: mem :: transmute (priority_present) } ; priority_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let runtime_present : u32 = unsafe { :: std :: mem :: transmute (runtime_present) } ; runtime_present as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let deadline_present : u32 = unsafe { :: std :: mem :: transmute (deadline_present) } ; deadline_present as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let period_present : u32 = unsafe { :: std :: mem :: transmute (period_present) } ; period_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_schema_process_scheduler (ptr : * mut runtime_spec_schema_config_schema_process_scheduler) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_process_scheduler (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_process_scheduler ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_process_scheduler (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_process_scheduler , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_process_rlimits_element { pub hard : u64 , pub soft : u64 , pub type_ : * mut :: std :: os :: raw :: c_char , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_process_rlimits_element () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_process_rlimits_element > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_process_rlimits_element > () , 32usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_process_rlimits_element))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_process_rlimits_element > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_process_rlimits_element))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hard) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_rlimits_element) , "::" , stringify ! (hard))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . soft) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_rlimits_element) , "::" , stringify ! (soft))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process_rlimits_element) , "::" , stringify ! (type_))) ; } impl runtime_spec_schema_config_schema_process_rlimits_element { # [inline] pub fn hard_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_hard_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn soft_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_soft_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (hard_present : :: std :: os :: raw :: c_uint , soft_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let hard_present : u32 = unsafe { :: std :: mem :: transmute (hard_present) } ; hard_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let soft_present : u32 = unsafe { :: std :: mem :: transmute (soft_present) } ; soft_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_schema_process_rlimits_element (ptr : * mut runtime_spec_schema_config_schema_process_rlimits_element) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_process_rlimits_element (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_process_rlimits_element ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema_process { pub args : * mut * mut :: std :: os :: raw :: c_char , pub args_len : usize , pub command_line : * mut :: std :: os :: raw :: c_char , pub console_size : * mut runtime_spec_schema_config_schema_process_console_size , pub cwd : * mut :: std :: os :: raw :: c_char , pub env : * mut * mut :: std :: os :: raw :: c_char , pub env_len : usize , pub terminal : bool , pub user : * mut runtime_spec_schema_config_schema_process_user , pub capabilities : * mut runtime_spec_schema_config_schema_process_capabilities , pub apparmor_profile : * mut :: std :: os :: raw :: c_char , pub oom_score_adj : :: std :: os :: raw :: c_int , pub selinux_label : * mut :: std :: os :: raw :: c_char , pub io_priority : * mut runtime_spec_schema_config_schema_process_io_priority , pub no_new_privileges : bool , pub scheduler : * mut runtime_spec_schema_config_schema_process_scheduler , pub rlimits : * mut * mut runtime_spec_schema_config_schema_process_rlimits_element , pub rlimits_len : usize , pub _residual : yajl_val , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : [u8 ; 7usize] , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema_process () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema_process > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema_process > () , 160usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema_process))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema_process > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema_process))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . args) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (args))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . args_len) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (args_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . command_line) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (command_line))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . console_size) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (console_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cwd) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (cwd))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . env) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (env))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . env_len) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (env_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . terminal) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (terminal))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . user) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (user))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . capabilities) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (capabilities))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . apparmor_profile) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (apparmor_profile))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . oom_score_adj) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (oom_score_adj))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . selinux_label) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (selinux_label))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . io_priority) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (io_priority))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . no_new_privileges) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (no_new_privileges))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . scheduler) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (scheduler))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rlimits) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (rlimits))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rlimits_len) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (rlimits_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema_process) , "::" , stringify ! (_residual))) ; } impl runtime_spec_schema_config_schema_process { # [inline] pub fn terminal_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_terminal_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn oom_score_adj_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_oom_score_adj_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn no_new_privileges_present (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_no_new_privileges_present (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (terminal_present : :: std :: os :: raw :: c_uint , oom_score_adj_present : :: std :: os :: raw :: c_uint , no_new_privileges_present : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let terminal_present : u32 = unsafe { :: std :: mem :: transmute (terminal_present) } ; terminal_present as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let oom_score_adj_present : u32 = unsafe { :: std :: mem :: transmute (oom_score_adj_present) } ; oom_score_adj_present as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let no_new_privileges_present : u32 = unsafe { :: std :: mem :: transmute (no_new_privileges_present) } ; no_new_privileges_present as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn free_runtime_spec_schema_config_schema_process (ptr : * mut runtime_spec_schema_config_schema_process) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema_process (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema_process ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema_process (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema_process , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct runtime_spec_schema_config_schema { pub oci_version : * mut :: std :: os :: raw :: c_char , pub hooks : * mut runtime_spec_schema_config_schema_hooks , pub annotations : * mut json_map_string_string , pub hostname : * mut :: std :: os :: raw :: c_char , pub domainname : * mut :: std :: os :: raw :: c_char , pub mounts : * mut * mut runtime_spec_schema_defs_mount , pub mounts_len : usize , pub root : * mut runtime_spec_schema_config_schema_root , pub process : * mut runtime_spec_schema_config_schema_process , pub linux : * mut runtime_spec_schema_config_linux , pub solaris : * mut runtime_spec_schema_config_solaris , pub windows : * mut runtime_spec_schema_config_windows , pub vm : * mut runtime_spec_schema_config_vm , pub zos : * mut runtime_spec_schema_config_zos , pub _residual : yajl_val , } # [test] fn bindgen_test_layout_runtime_spec_schema_config_schema () { const UNINIT : :: std :: mem :: MaybeUninit < runtime_spec_schema_config_schema > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < runtime_spec_schema_config_schema > () , 120usize , concat ! ("Size of: " , stringify ! (runtime_spec_schema_config_schema))) ; assert_eq ! (:: std :: mem :: align_of :: < runtime_spec_schema_config_schema > () , 8usize , concat ! ("Alignment of " , stringify ! (runtime_spec_schema_config_schema))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . oci_version) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (oci_version))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hooks) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (hooks))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . annotations) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (annotations))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hostname) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (hostname))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . domainname) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (domainname))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mounts) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (mounts))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mounts_len) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (mounts_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . root) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (root))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . process) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (process))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . linux) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (linux))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . solaris) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (solaris))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . windows) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (windows))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . vm) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (vm))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . zos) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (zos))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _residual) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (runtime_spec_schema_config_schema) , "::" , stringify ! (_residual))) ; } extern "C" { pub fn free_runtime_spec_schema_config_schema (ptr : * mut runtime_spec_schema_config_schema) ; } extern "C" { pub fn make_runtime_spec_schema_config_schema (tree : yajl_val , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema ; } extern "C" { pub fn gen_runtime_spec_schema_config_schema (g : yajl_gen , ptr : * const runtime_spec_schema_config_schema , ctx : * const parser_context , err : * mut parser_error) -> yajl_gen_status ; } extern "C" { pub fn runtime_spec_schema_config_schema_parse_file (filename : * const :: std :: os :: raw :: c_char , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema ; } extern "C" { pub fn runtime_spec_schema_config_schema_parse_file_stream (stream : * mut FILE , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema ; } extern "C" { pub fn runtime_spec_schema_config_schema_parse_data (jsondata : * const :: std :: os :: raw :: c_char , ctx : * const parser_context , err : * mut parser_error) -> * mut runtime_spec_schema_config_schema ; } extern "C" { pub fn runtime_spec_schema_config_schema_generate_json (ptr : * const runtime_spec_schema_config_schema , ctx : * const parser_context , err : * mut parser_error) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn closelog () ; } extern "C" { pub fn openlog (__ident : * const :: std :: os :: raw :: c_char , __option : :: std :: os :: raw :: c_int , __facility : :: std :: os :: raw :: c_int) ; } extern "C" { pub fn setlogmask (__mask : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn syslog (__pri : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ...) ; } extern "C" { pub fn vsyslog (__pri : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __ap : * mut __va_list_tag) ; } pub type useconds_t = __useconds_t ; pub type socklen_t = __socklen_t ; extern "C" { pub fn access (__name : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn faccessat (__fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int , __flag : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lseek (__fd : :: std :: os :: raw :: c_int , __offset : __off_t , __whence : :: std :: os :: raw :: c_int) -> __off_t ; } extern "C" { pub fn close (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn closefrom (__lowfd : :: std :: os :: raw :: c_int) ; } extern "C" { pub fn read (__fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize) -> isize ; } extern "C" { pub fn write (__fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize) -> isize ; } extern "C" { pub fn pread (__fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize , __offset : __off_t) -> isize ; } extern "C" { pub fn pwrite (__fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __offset : __off_t) -> isize ; } extern "C" { pub fn pipe (__pipedes : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn alarm (__seconds : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn sleep (__seconds : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn ualarm (__value : __useconds_t , __interval : __useconds_t) -> __useconds_t ; } extern "C" { pub fn usleep (__useconds : __useconds_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pause () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn chown (__file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fchown (__fd : :: std :: os :: raw :: c_int , __owner : __uid_t , __group : __gid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lchown (__file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fchownat (__fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t , __flag : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn chdir (__path : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fchdir (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getcwd (__buf : * mut :: std :: os :: raw :: c_char , __size : usize) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn getwd (__buf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn dup (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn dup2 (__fd : :: std :: os :: raw :: c_int , __fd2 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub static mut __environ : * mut * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn execve (__path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fexecve (__fd : :: std :: os :: raw :: c_int , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn execv (__path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn execle (__path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn execl (__path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn execvp (__file : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn execlp (__file : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn nice (__inc : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _exit (__status : :: std :: os :: raw :: c_int) -> ! ; } pub const _PC_LINK_MAX : _bindgen_ty_1 = 0 ; pub const _PC_MAX_CANON : _bindgen_ty_1 = 1 ; pub const _PC_MAX_INPUT : _bindgen_ty_1 = 2 ; pub const _PC_NAME_MAX : _bindgen_ty_1 = 3 ; pub const _PC_PATH_MAX : _bindgen_ty_1 = 4 ; pub const _PC_PIPE_BUF : _bindgen_ty_1 = 5 ; pub const _PC_CHOWN_RESTRICTED : _bindgen_ty_1 = 6 ; pub const _PC_NO_TRUNC : _bindgen_ty_1 = 7 ; pub const _PC_VDISABLE : _bindgen_ty_1 = 8 ; pub const _PC_SYNC_IO : _bindgen_ty_1 = 9 ; pub const _PC_ASYNC_IO : _bindgen_ty_1 = 10 ; pub const _PC_PRIO_IO : _bindgen_ty_1 = 11 ; pub const _PC_SOCK_MAXBUF : _bindgen_ty_1 = 12 ; pub const _PC_FILESIZEBITS : _bindgen_ty_1 = 13 ; pub const _PC_REC_INCR_XFER_SIZE : _bindgen_ty_1 = 14 ; pub const _PC_REC_MAX_XFER_SIZE : _bindgen_ty_1 = 15 ; pub const _PC_REC_MIN_XFER_SIZE : _bindgen_ty_1 = 16 ; pub const _PC_REC_XFER_ALIGN : _bindgen_ty_1 = 17 ; pub const _PC_ALLOC_SIZE_MIN : _bindgen_ty_1 = 18 ; pub const _PC_SYMLINK_MAX : _bindgen_ty_1 = 19 ; pub const _PC_2_SYMLINKS : _bindgen_ty_1 = 20 ; pub type _bindgen_ty_1 = :: std :: os :: raw :: c_uint ; pub const _SC_ARG_MAX : _bindgen_ty_2 = 0 ; pub const _SC_CHILD_MAX : _bindgen_ty_2 = 1 ; pub const _SC_CLK_TCK : _bindgen_ty_2 = 2 ; pub const _SC_NGROUPS_MAX : _bindgen_ty_2 = 3 ; pub const _SC_OPEN_MAX : _bindgen_ty_2 = 4 ; pub const _SC_STREAM_MAX : _bindgen_ty_2 = 5 ; pub const _SC_TZNAME_MAX : _bindgen_ty_2 = 6 ; pub const _SC_JOB_CONTROL : _bindgen_ty_2 = 7 ; pub const _SC_SAVED_IDS : _bindgen_ty_2 = 8 ; pub const _SC_REALTIME_SIGNALS : _bindgen_ty_2 = 9 ; pub const _SC_PRIORITY_SCHEDULING : _bindgen_ty_2 = 10 ; pub const _SC_TIMERS : _bindgen_ty_2 = 11 ; pub const _SC_ASYNCHRONOUS_IO : _bindgen_ty_2 = 12 ; pub const _SC_PRIORITIZED_IO : _bindgen_ty_2 = 13 ; pub const _SC_SYNCHRONIZED_IO : _bindgen_ty_2 = 14 ; pub const _SC_FSYNC : _bindgen_ty_2 = 15 ; pub const _SC_MAPPED_FILES : _bindgen_ty_2 = 16 ; pub const _SC_MEMLOCK : _bindgen_ty_2 = 17 ; pub const _SC_MEMLOCK_RANGE : _bindgen_ty_2 = 18 ; pub const _SC_MEMORY_PROTECTION : _bindgen_ty_2 = 19 ; pub const _SC_MESSAGE_PASSING : _bindgen_ty_2 = 20 ; pub const _SC_SEMAPHORES : _bindgen_ty_2 = 21 ; pub const _SC_SHARED_MEMORY_OBJECTS : _bindgen_ty_2 = 22 ; pub const _SC_AIO_LISTIO_MAX : _bindgen_ty_2 = 23 ; pub const _SC_AIO_MAX : _bindgen_ty_2 = 24 ; pub const _SC_AIO_PRIO_DELTA_MAX : _bindgen_ty_2 = 25 ; pub const _SC_DELAYTIMER_MAX : _bindgen_ty_2 = 26 ; pub const _SC_MQ_OPEN_MAX : _bindgen_ty_2 = 27 ; pub const _SC_MQ_PRIO_MAX : _bindgen_ty_2 = 28 ; pub const _SC_VERSION : _bindgen_ty_2 = 29 ; pub const _SC_PAGESIZE : _bindgen_ty_2 = 30 ; pub const _SC_RTSIG_MAX : _bindgen_ty_2 = 31 ; pub const _SC_SEM_NSEMS_MAX : _bindgen_ty_2 = 32 ; pub const _SC_SEM_VALUE_MAX : _bindgen_ty_2 = 33 ; pub const _SC_SIGQUEUE_MAX : _bindgen_ty_2 = 34 ; pub const _SC_TIMER_MAX : _bindgen_ty_2 = 35 ; pub const _SC_BC_BASE_MAX : _bindgen_ty_2 = 36 ; pub const _SC_BC_DIM_MAX : _bindgen_ty_2 = 37 ; pub const _SC_BC_SCALE_MAX : _bindgen_ty_2 = 38 ; pub const _SC_BC_STRING_MAX : _bindgen_ty_2 = 39 ; pub const _SC_COLL_WEIGHTS_MAX : _bindgen_ty_2 = 40 ; pub const _SC_EQUIV_CLASS_MAX : _bindgen_ty_2 = 41 ; pub const _SC_EXPR_NEST_MAX : _bindgen_ty_2 = 42 ; pub const _SC_LINE_MAX : _bindgen_ty_2 = 43 ; pub const _SC_RE_DUP_MAX : _bindgen_ty_2 = 44 ; pub const _SC_CHARCLASS_NAME_MAX : _bindgen_ty_2 = 45 ; pub const _SC_2_VERSION : _bindgen_ty_2 = 46 ; pub const _SC_2_C_BIND : _bindgen_ty_2 = 47 ; pub const _SC_2_C_DEV : _bindgen_ty_2 = 48 ; pub const _SC_2_FORT_DEV : _bindgen_ty_2 = 49 ; pub const _SC_2_FORT_RUN : _bindgen_ty_2 = 50 ; pub const _SC_2_SW_DEV : _bindgen_ty_2 = 51 ; pub const _SC_2_LOCALEDEF : _bindgen_ty_2 = 52 ; pub const _SC_PII : _bindgen_ty_2 = 53 ; pub const _SC_PII_XTI : _bindgen_ty_2 = 54 ; pub const _SC_PII_SOCKET : _bindgen_ty_2 = 55 ; pub const _SC_PII_INTERNET : _bindgen_ty_2 = 56 ; pub const _SC_PII_OSI : _bindgen_ty_2 = 57 ; pub const _SC_POLL : _bindgen_ty_2 = 58 ; pub const _SC_SELECT : _bindgen_ty_2 = 59 ; pub const _SC_UIO_MAXIOV : _bindgen_ty_2 = 60 ; pub const _SC_IOV_MAX : _bindgen_ty_2 = 60 ; pub const _SC_PII_INTERNET_STREAM : _bindgen_ty_2 = 61 ; pub const _SC_PII_INTERNET_DGRAM : _bindgen_ty_2 = 62 ; pub const _SC_PII_OSI_COTS : _bindgen_ty_2 = 63 ; pub const _SC_PII_OSI_CLTS : _bindgen_ty_2 = 64 ; pub const _SC_PII_OSI_M : _bindgen_ty_2 = 65 ; pub const _SC_T_IOV_MAX : _bindgen_ty_2 = 66 ; pub const _SC_THREADS : _bindgen_ty_2 = 67 ; pub const _SC_THREAD_SAFE_FUNCTIONS : _bindgen_ty_2 = 68 ; pub const _SC_GETGR_R_SIZE_MAX : _bindgen_ty_2 = 69 ; pub const _SC_GETPW_R_SIZE_MAX : _bindgen_ty_2 = 70 ; pub const _SC_LOGIN_NAME_MAX : _bindgen_ty_2 = 71 ; pub const _SC_TTY_NAME_MAX : _bindgen_ty_2 = 72 ; pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : _bindgen_ty_2 = 73 ; pub const _SC_THREAD_KEYS_MAX : _bindgen_ty_2 = 74 ; pub const _SC_THREAD_STACK_MIN : _bindgen_ty_2 = 75 ; pub const _SC_THREAD_THREADS_MAX : _bindgen_ty_2 = 76 ; pub const _SC_THREAD_ATTR_STACKADDR : _bindgen_ty_2 = 77 ; pub const _SC_THREAD_ATTR_STACKSIZE : _bindgen_ty_2 = 78 ; pub const _SC_THREAD_PRIORITY_SCHEDULING : _bindgen_ty_2 = 79 ; pub const _SC_THREAD_PRIO_INHERIT : _bindgen_ty_2 = 80 ; pub const _SC_THREAD_PRIO_PROTECT : _bindgen_ty_2 = 81 ; pub const _SC_THREAD_PROCESS_SHARED : _bindgen_ty_2 = 82 ; pub const _SC_NPROCESSORS_CONF : _bindgen_ty_2 = 83 ; pub const _SC_NPROCESSORS_ONLN : _bindgen_ty_2 = 84 ; pub const _SC_PHYS_PAGES : _bindgen_ty_2 = 85 ; pub const _SC_AVPHYS_PAGES : _bindgen_ty_2 = 86 ; pub const _SC_ATEXIT_MAX : _bindgen_ty_2 = 87 ; pub const _SC_PASS_MAX : _bindgen_ty_2 = 88 ; pub const _SC_XOPEN_VERSION : _bindgen_ty_2 = 89 ; pub const _SC_XOPEN_XCU_VERSION : _bindgen_ty_2 = 90 ; pub const _SC_XOPEN_UNIX : _bindgen_ty_2 = 91 ; pub const _SC_XOPEN_CRYPT : _bindgen_ty_2 = 92 ; pub const _SC_XOPEN_ENH_I18N : _bindgen_ty_2 = 93 ; pub const _SC_XOPEN_SHM : _bindgen_ty_2 = 94 ; pub const _SC_2_CHAR_TERM : _bindgen_ty_2 = 95 ; pub const _SC_2_C_VERSION : _bindgen_ty_2 = 96 ; pub const _SC_2_UPE : _bindgen_ty_2 = 97 ; pub const _SC_XOPEN_XPG2 : _bindgen_ty_2 = 98 ; pub const _SC_XOPEN_XPG3 : _bindgen_ty_2 = 99 ; pub const _SC_XOPEN_XPG4 : _bindgen_ty_2 = 100 ; pub const _SC_CHAR_BIT : _bindgen_ty_2 = 101 ; pub const _SC_CHAR_MAX : _bindgen_ty_2 = 102 ; pub const _SC_CHAR_MIN : _bindgen_ty_2 = 103 ; pub const _SC_INT_MAX : _bindgen_ty_2 = 104 ; pub const _SC_INT_MIN : _bindgen_ty_2 = 105 ; pub const _SC_LONG_BIT : _bindgen_ty_2 = 106 ; pub const _SC_WORD_BIT : _bindgen_ty_2 = 107 ; pub const _SC_MB_LEN_MAX : _bindgen_ty_2 = 108 ; pub const _SC_NZERO : _bindgen_ty_2 = 109 ; pub const _SC_SSIZE_MAX : _bindgen_ty_2 = 110 ; pub const _SC_SCHAR_MAX : _bindgen_ty_2 = 111 ; pub const _SC_SCHAR_MIN : _bindgen_ty_2 = 112 ; pub const _SC_SHRT_MAX : _bindgen_ty_2 = 113 ; pub const _SC_SHRT_MIN : _bindgen_ty_2 = 114 ; pub const _SC_UCHAR_MAX : _bindgen_ty_2 = 115 ; pub const _SC_UINT_MAX : _bindgen_ty_2 = 116 ; pub const _SC_ULONG_MAX : _bindgen_ty_2 = 117 ; pub const _SC_USHRT_MAX : _bindgen_ty_2 = 118 ; pub const _SC_NL_ARGMAX : _bindgen_ty_2 = 119 ; pub const _SC_NL_LANGMAX : _bindgen_ty_2 = 120 ; pub const _SC_NL_MSGMAX : _bindgen_ty_2 = 121 ; pub const _SC_NL_NMAX : _bindgen_ty_2 = 122 ; pub const _SC_NL_SETMAX : _bindgen_ty_2 = 123 ; pub const _SC_NL_TEXTMAX : _bindgen_ty_2 = 124 ; pub const _SC_XBS5_ILP32_OFF32 : _bindgen_ty_2 = 125 ; pub const _SC_XBS5_ILP32_OFFBIG : _bindgen_ty_2 = 126 ; pub const _SC_XBS5_LP64_OFF64 : _bindgen_ty_2 = 127 ; pub const _SC_XBS5_LPBIG_OFFBIG : _bindgen_ty_2 = 128 ; pub const _SC_XOPEN_LEGACY : _bindgen_ty_2 = 129 ; pub const _SC_XOPEN_REALTIME : _bindgen_ty_2 = 130 ; pub const _SC_XOPEN_REALTIME_THREADS : _bindgen_ty_2 = 131 ; pub const _SC_ADVISORY_INFO : _bindgen_ty_2 = 132 ; pub const _SC_BARRIERS : _bindgen_ty_2 = 133 ; pub const _SC_BASE : _bindgen_ty_2 = 134 ; pub const _SC_C_LANG_SUPPORT : _bindgen_ty_2 = 135 ; pub const _SC_C_LANG_SUPPORT_R : _bindgen_ty_2 = 136 ; pub const _SC_CLOCK_SELECTION : _bindgen_ty_2 = 137 ; pub const _SC_CPUTIME : _bindgen_ty_2 = 138 ; pub const _SC_THREAD_CPUTIME : _bindgen_ty_2 = 139 ; pub const _SC_DEVICE_IO : _bindgen_ty_2 = 140 ; pub const _SC_DEVICE_SPECIFIC : _bindgen_ty_2 = 141 ; pub const _SC_DEVICE_SPECIFIC_R : _bindgen_ty_2 = 142 ; pub const _SC_FD_MGMT : _bindgen_ty_2 = 143 ; pub const _SC_FIFO : _bindgen_ty_2 = 144 ; pub const _SC_PIPE : _bindgen_ty_2 = 145 ; pub const _SC_FILE_ATTRIBUTES : _bindgen_ty_2 = 146 ; pub const _SC_FILE_LOCKING : _bindgen_ty_2 = 147 ; pub const _SC_FILE_SYSTEM : _bindgen_ty_2 = 148 ; pub const _SC_MONOTONIC_CLOCK : _bindgen_ty_2 = 149 ; pub const _SC_MULTI_PROCESS : _bindgen_ty_2 = 150 ; pub const _SC_SINGLE_PROCESS : _bindgen_ty_2 = 151 ; pub const _SC_NETWORKING : _bindgen_ty_2 = 152 ; pub const _SC_READER_WRITER_LOCKS : _bindgen_ty_2 = 153 ; pub const _SC_SPIN_LOCKS : _bindgen_ty_2 = 154 ; pub const _SC_REGEXP : _bindgen_ty_2 = 155 ; pub const _SC_REGEX_VERSION : _bindgen_ty_2 = 156 ; pub const _SC_SHELL : _bindgen_ty_2 = 157 ; pub const _SC_SIGNALS : _bindgen_ty_2 = 158 ; pub const _SC_SPAWN : _bindgen_ty_2 = 159 ; pub const _SC_SPORADIC_SERVER : _bindgen_ty_2 = 160 ; pub const _SC_THREAD_SPORADIC_SERVER : _bindgen_ty_2 = 161 ; pub const _SC_SYSTEM_DATABASE : _bindgen_ty_2 = 162 ; pub const _SC_SYSTEM_DATABASE_R : _bindgen_ty_2 = 163 ; pub const _SC_TIMEOUTS : _bindgen_ty_2 = 164 ; pub const _SC_TYPED_MEMORY_OBJECTS : _bindgen_ty_2 = 165 ; pub const _SC_USER_GROUPS : _bindgen_ty_2 = 166 ; pub const _SC_USER_GROUPS_R : _bindgen_ty_2 = 167 ; pub const _SC_2_PBS : _bindgen_ty_2 = 168 ; pub const _SC_2_PBS_ACCOUNTING : _bindgen_ty_2 = 169 ; pub const _SC_2_PBS_LOCATE : _bindgen_ty_2 = 170 ; pub const _SC_2_PBS_MESSAGE : _bindgen_ty_2 = 171 ; pub const _SC_2_PBS_TRACK : _bindgen_ty_2 = 172 ; pub const _SC_SYMLOOP_MAX : _bindgen_ty_2 = 173 ; pub const _SC_STREAMS : _bindgen_ty_2 = 174 ; pub const _SC_2_PBS_CHECKPOINT : _bindgen_ty_2 = 175 ; pub const _SC_V6_ILP32_OFF32 : _bindgen_ty_2 = 176 ; pub const _SC_V6_ILP32_OFFBIG : _bindgen_ty_2 = 177 ; pub const _SC_V6_LP64_OFF64 : _bindgen_ty_2 = 178 ; pub const _SC_V6_LPBIG_OFFBIG : _bindgen_ty_2 = 179 ; pub const _SC_HOST_NAME_MAX : _bindgen_ty_2 = 180 ; pub const _SC_TRACE : _bindgen_ty_2 = 181 ; pub const _SC_TRACE_EVENT_FILTER : _bindgen_ty_2 = 182 ; pub const _SC_TRACE_INHERIT : _bindgen_ty_2 = 183 ; pub const _SC_TRACE_LOG : _bindgen_ty_2 = 184 ; pub const _SC_LEVEL1_ICACHE_SIZE : _bindgen_ty_2 = 185 ; pub const _SC_LEVEL1_ICACHE_ASSOC : _bindgen_ty_2 = 186 ; pub const _SC_LEVEL1_ICACHE_LINESIZE : _bindgen_ty_2 = 187 ; pub const _SC_LEVEL1_DCACHE_SIZE : _bindgen_ty_2 = 188 ; pub const _SC_LEVEL1_DCACHE_ASSOC : _bindgen_ty_2 = 189 ; pub const _SC_LEVEL1_DCACHE_LINESIZE : _bindgen_ty_2 = 190 ; pub const _SC_LEVEL2_CACHE_SIZE : _bindgen_ty_2 = 191 ; pub const _SC_LEVEL2_CACHE_ASSOC : _bindgen_ty_2 = 192 ; pub const _SC_LEVEL2_CACHE_LINESIZE : _bindgen_ty_2 = 193 ; pub const _SC_LEVEL3_CACHE_SIZE : _bindgen_ty_2 = 194 ; pub const _SC_LEVEL3_CACHE_ASSOC : _bindgen_ty_2 = 195 ; pub const _SC_LEVEL3_CACHE_LINESIZE : _bindgen_ty_2 = 196 ; pub const _SC_LEVEL4_CACHE_SIZE : _bindgen_ty_2 = 197 ; pub const _SC_LEVEL4_CACHE_ASSOC : _bindgen_ty_2 = 198 ; pub const _SC_LEVEL4_CACHE_LINESIZE : _bindgen_ty_2 = 199 ; pub const _SC_IPV6 : _bindgen_ty_2 = 235 ; pub const _SC_RAW_SOCKETS : _bindgen_ty_2 = 236 ; pub const _SC_V7_ILP32_OFF32 : _bindgen_ty_2 = 237 ; pub const _SC_V7_ILP32_OFFBIG : _bindgen_ty_2 = 238 ; pub const _SC_V7_LP64_OFF64 : _bindgen_ty_2 = 239 ; pub const _SC_V7_LPBIG_OFFBIG : _bindgen_ty_2 = 240 ; pub const _SC_SS_REPL_MAX : _bindgen_ty_2 = 241 ; pub const _SC_TRACE_EVENT_NAME_MAX : _bindgen_ty_2 = 242 ; pub const _SC_TRACE_NAME_MAX : _bindgen_ty_2 = 243 ; pub const _SC_TRACE_SYS_MAX : _bindgen_ty_2 = 244 ; pub const _SC_TRACE_USER_EVENT_MAX : _bindgen_ty_2 = 245 ; pub const _SC_XOPEN_STREAMS : _bindgen_ty_2 = 246 ; pub const _SC_THREAD_ROBUST_PRIO_INHERIT : _bindgen_ty_2 = 247 ; pub const _SC_THREAD_ROBUST_PRIO_PROTECT : _bindgen_ty_2 = 248 ; pub const _SC_MINSIGSTKSZ : _bindgen_ty_2 = 249 ; pub const _SC_SIGSTKSZ : _bindgen_ty_2 = 250 ; pub type _bindgen_ty_2 = :: std :: os :: raw :: c_uint ; pub const _CS_PATH : _bindgen_ty_3 = 0 ; pub const _CS_V6_WIDTH_RESTRICTED_ENVS : _bindgen_ty_3 = 1 ; pub const _CS_GNU_LIBC_VERSION : _bindgen_ty_3 = 2 ; pub const _CS_GNU_LIBPTHREAD_VERSION : _bindgen_ty_3 = 3 ; pub const _CS_V5_WIDTH_RESTRICTED_ENVS : _bindgen_ty_3 = 4 ; pub const _CS_V7_WIDTH_RESTRICTED_ENVS : _bindgen_ty_3 = 5 ; pub const _CS_LFS_CFLAGS : _bindgen_ty_3 = 1000 ; pub const _CS_LFS_LDFLAGS : _bindgen_ty_3 = 1001 ; pub const _CS_LFS_LIBS : _bindgen_ty_3 = 1002 ; pub const _CS_LFS_LINTFLAGS : _bindgen_ty_3 = 1003 ; pub const _CS_LFS64_CFLAGS : _bindgen_ty_3 = 1004 ; pub const _CS_LFS64_LDFLAGS : _bindgen_ty_3 = 1005 ; pub const _CS_LFS64_LIBS : _bindgen_ty_3 = 1006 ; pub const _CS_LFS64_LINTFLAGS : _bindgen_ty_3 = 1007 ; pub const _CS_XBS5_ILP32_OFF32_CFLAGS : _bindgen_ty_3 = 1100 ; pub const _CS_XBS5_ILP32_OFF32_LDFLAGS : _bindgen_ty_3 = 1101 ; pub const _CS_XBS5_ILP32_OFF32_LIBS : _bindgen_ty_3 = 1102 ; pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS : _bindgen_ty_3 = 1103 ; pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS : _bindgen_ty_3 = 1104 ; pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_3 = 1105 ; pub const _CS_XBS5_ILP32_OFFBIG_LIBS : _bindgen_ty_3 = 1106 ; pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_3 = 1107 ; pub const _CS_XBS5_LP64_OFF64_CFLAGS : _bindgen_ty_3 = 1108 ; pub const _CS_XBS5_LP64_OFF64_LDFLAGS : _bindgen_ty_3 = 1109 ; pub const _CS_XBS5_LP64_OFF64_LIBS : _bindgen_ty_3 = 1110 ; pub const _CS_XBS5_LP64_OFF64_LINTFLAGS : _bindgen_ty_3 = 1111 ; pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_3 = 1112 ; pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_3 = 1113 ; pub const _CS_XBS5_LPBIG_OFFBIG_LIBS : _bindgen_ty_3 = 1114 ; pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_3 = 1115 ; pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS : _bindgen_ty_3 = 1116 ; pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS : _bindgen_ty_3 = 1117 ; pub const _CS_POSIX_V6_ILP32_OFF32_LIBS : _bindgen_ty_3 = 1118 ; pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS : _bindgen_ty_3 = 1119 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS : _bindgen_ty_3 = 1120 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_3 = 1121 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS : _bindgen_ty_3 = 1122 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_3 = 1123 ; pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS : _bindgen_ty_3 = 1124 ; pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS : _bindgen_ty_3 = 1125 ; pub const _CS_POSIX_V6_LP64_OFF64_LIBS : _bindgen_ty_3 = 1126 ; pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS : _bindgen_ty_3 = 1127 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_3 = 1128 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_3 = 1129 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS : _bindgen_ty_3 = 1130 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_3 = 1131 ; pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS : _bindgen_ty_3 = 1132 ; pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS : _bindgen_ty_3 = 1133 ; pub const _CS_POSIX_V7_ILP32_OFF32_LIBS : _bindgen_ty_3 = 1134 ; pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS : _bindgen_ty_3 = 1135 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS : _bindgen_ty_3 = 1136 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_3 = 1137 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS : _bindgen_ty_3 = 1138 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_3 = 1139 ; pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS : _bindgen_ty_3 = 1140 ; pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS : _bindgen_ty_3 = 1141 ; pub const _CS_POSIX_V7_LP64_OFF64_LIBS : _bindgen_ty_3 = 1142 ; pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS : _bindgen_ty_3 = 1143 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_3 = 1144 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_3 = 1145 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS : _bindgen_ty_3 = 1146 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_3 = 1147 ; pub const _CS_V6_ENV : _bindgen_ty_3 = 1148 ; pub const _CS_V7_ENV : _bindgen_ty_3 = 1149 ; pub type _bindgen_ty_3 = :: std :: os :: raw :: c_uint ; extern "C" { pub fn pathconf (__path : * const :: std :: os :: raw :: c_char , __name : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn fpathconf (__fd : :: std :: os :: raw :: c_int , __name : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn sysconf (__name : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn confstr (__name : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> usize ; } extern "C" { pub fn getpid () -> __pid_t ; } extern "C" { pub fn getppid () -> __pid_t ; } extern "C" { pub fn getpgrp () -> __pid_t ; } extern "C" { pub fn __getpgid (__pid : __pid_t) -> __pid_t ; } extern "C" { pub fn getpgid (__pid : __pid_t) -> __pid_t ; } extern "C" { pub fn setpgid (__pid : __pid_t , __pgid : __pid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setpgrp () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setsid () -> __pid_t ; } extern "C" { pub fn getsid (__pid : __pid_t) -> __pid_t ; } extern "C" { pub fn getuid () -> __uid_t ; } extern "C" { pub fn geteuid () -> __uid_t ; } extern "C" { pub fn getgid () -> __gid_t ; } extern "C" { pub fn getegid () -> __gid_t ; } extern "C" { pub fn getgroups (__size : :: std :: os :: raw :: c_int , __list : * mut __gid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setuid (__uid : __uid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setreuid (__ruid : __uid_t , __euid : __uid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn seteuid (__uid : __uid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setgid (__gid : __gid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setregid (__rgid : __gid_t , __egid : __gid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setegid (__gid : __gid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fork () -> __pid_t ; } extern "C" { pub fn vfork () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ttyname (__fd : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ttyname_r (__fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isatty (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ttyslot () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn link (__from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn linkat (__fromfd : :: std :: os :: raw :: c_int , __from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char , __flags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn symlink (__from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn readlink (__path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> isize ; } extern "C" { pub fn symlinkat (__from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn readlinkat (__fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize) -> isize ; } extern "C" { pub fn unlink (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn unlinkat (__fd : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __flag : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rmdir (__path : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tcgetpgrp (__fd : :: std :: os :: raw :: c_int) -> __pid_t ; } extern "C" { pub fn tcsetpgrp (__fd : :: std :: os :: raw :: c_int , __pgrp_id : __pid_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getlogin () -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn getlogin_r (__name : * mut :: std :: os :: raw :: c_char , __name_len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setlogin (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub static mut optarg : * mut :: std :: os :: raw :: c_char ; } extern "C" { pub static mut optind : :: std :: os :: raw :: c_int ; } extern "C" { pub static mut opterr : :: std :: os :: raw :: c_int ; } extern "C" { pub static mut optopt : :: std :: os :: raw :: c_int ; } extern "C" { pub fn getopt (___argc : :: std :: os :: raw :: c_int , ___argv : * const * mut :: std :: os :: raw :: c_char , __shortopts : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn gethostname (__name : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sethostname (__name : * const :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sethostid (__id : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getdomainname (__name : * mut :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setdomainname (__name : * const :: std :: os :: raw :: c_char , __len : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vhangup () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn revoke (__file : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn profil (__sample_buffer : * mut :: std :: os :: raw :: c_ushort , __size : usize , __offset : usize , __scale : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn acct (__name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getusershell () -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn endusershell () ; } extern "C" { pub fn setusershell () ; } extern "C" { pub fn daemon (__nochdir : :: std :: os :: raw :: c_int , __noclose : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn chroot (__path : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getpass (__prompt : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fsync (__fd : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn gethostid () -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn sync () ; } extern "C" { pub fn getpagesize () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getdtablesize () -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn truncate (__file : * const :: std :: os :: raw :: c_char , __length : __off_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftruncate (__fd : :: std :: os :: raw :: c_int , __length : __off_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn brk (__addr : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sbrk (__delta : isize) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn syscall (__sysno : :: std :: os :: raw :: c_long , ...) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn lockf (__fd : :: std :: os :: raw :: c_int , __cmd : :: std :: os :: raw :: c_int , __len : __off_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fdatasync (__fildes : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn crypt (__key : * const :: std :: os :: raw :: c_char , __salt : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn getentropy (__buffer : * mut :: std :: os :: raw :: c_void , __length : usize) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_error_s { pub status : :: std :: os :: raw :: c_int , pub msg : * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_libcrun_error_s () { const UNINIT : :: std :: mem :: MaybeUninit < libcrun_error_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < libcrun_error_s > () , 16usize , concat ! ("Size of: " , stringify ! (libcrun_error_s))) ; assert_eq ! (:: std :: mem :: align_of :: < libcrun_error_s > () , 8usize , concat ! ("Alignment of " , stringify ! (libcrun_error_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . status) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (libcrun_error_s) , "::" , stringify ! (status))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . msg) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (libcrun_error_s) , "::" , stringify ! (msg))) ; } pub type libcrun_error_t = * mut libcrun_error_s ; pub type crun_output_handler = :: std :: option :: Option < unsafe extern "C" fn (errno_ : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , warning : bool , arg : * mut :: std :: os :: raw :: c_void) > ; extern "C" { pub fn crun_set_output_handler (handler : crun_output_handler , arg : * mut :: std :: os :: raw :: c_void , log_to_stderr : bool) ; } extern "C" { pub fn log_write_to_journald (errno_ : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , warning : bool , arg : * mut :: std :: os :: raw :: c_void) ; } extern "C" { pub fn log_write_to_syslog (errno_ : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , warning : bool , arg : * mut :: std :: os :: raw :: c_void) ; } extern "C" { pub fn log_write_to_stream (errno_ : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , warning : bool , arg : * mut :: std :: os :: raw :: c_void) ; } extern "C" { pub fn log_write_to_stderr (errno_ : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , warning : bool , arg : * mut :: std :: os :: raw :: c_void) ; } extern "C" { pub fn crun_error_wrap (err : * mut libcrun_error_t , fmt : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn crun_error_get_errno (err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn crun_error_release (err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn crun_error_write_warning_and_release (out : * mut FILE , err : * mut * mut libcrun_error_t) ; } extern "C" { pub fn libcrun_warning (msg : * const :: std :: os :: raw :: c_char , ...) ; } extern "C" { pub fn libcrun_error (errno_ : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , ...) ; } extern "C" { pub fn libcrun_make_error (err : * mut libcrun_error_t , status : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , ...) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_error_write_warning_and_release (out : * mut FILE , err : * mut * mut libcrun_error_t) ; } extern "C" { pub fn libcrun_fail_with_error (errno_ : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , ...) -> ! ; } extern "C" { pub fn libcrun_set_log_format (format : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_init_logging (output_handler : * mut crun_output_handler , output_handler_arg : * mut * mut :: std :: os :: raw :: c_void , id : * const :: std :: os :: raw :: c_char , log : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_error_release (err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn yajl_error_to_crun_error (yajl_status : :: std :: os :: raw :: c_int , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } pub const LIBCRUN_VERBOSITY_ERROR : _bindgen_ty_4 = 0 ; pub const LIBCRUN_VERBOSITY_WARNING : _bindgen_ty_4 = 1 ; pub type _bindgen_ty_4 = :: std :: os :: raw :: c_uint ; extern "C" { pub fn libcrun_set_verbosity (verbosity : :: std :: os :: raw :: c_int) ; } extern "C" { pub fn libcrun_get_verbosity () -> :: std :: os :: raw :: c_int ; } pub const handler_configure_phase_HANDLER_CONFIGURE_BEFORE_MOUNTS : handler_configure_phase = 1 ; pub const handler_configure_phase_HANDLER_CONFIGURE_AFTER_MOUNTS : handler_configure_phase = 2 ; pub const handler_configure_phase_HANDLER_CONFIGURE_MOUNTS : handler_configure_phase = 3 ; pub type handler_configure_phase = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct custom_handler_manager_s { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_context_s { pub state_root : * const :: std :: os :: raw :: c_char , pub id : * const :: std :: os :: raw :: c_char , pub bundle : * const :: std :: os :: raw :: c_char , pub console_socket : * const :: std :: os :: raw :: c_char , pub pid_file : * const :: std :: os :: raw :: c_char , pub notify_socket : * const :: std :: os :: raw :: c_char , pub handler : * const :: std :: os :: raw :: c_char , pub preserve_fds : :: std :: os :: raw :: c_int , pub listen_fds : :: std :: os :: raw :: c_int , pub output_handler : crun_output_handler , pub output_handler_arg : * mut :: std :: os :: raw :: c_void , pub fifo_exec_wait_fd : :: std :: os :: raw :: c_int , pub systemd_cgroup : bool , pub detach : bool , pub no_new_keyring : bool , pub force_no_cgroup : bool , pub no_pivot : bool , pub argv : * mut * mut :: std :: os :: raw :: c_char , pub argc : :: std :: os :: raw :: c_int , pub handler_manager : * mut custom_handler_manager_s , } # [test] fn bindgen_test_layout_libcrun_context_s () { const UNINIT : :: std :: mem :: MaybeUninit < libcrun_context_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < libcrun_context_s > () , 120usize , concat ! ("Size of: " , stringify ! (libcrun_context_s))) ; assert_eq ! (:: std :: mem :: align_of :: < libcrun_context_s > () , 8usize , concat ! ("Alignment of " , stringify ! (libcrun_context_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_root) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (state_root))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . id) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . bundle) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (bundle))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . console_socket) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (console_socket))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . pid_file) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (pid_file))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . notify_socket) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (notify_socket))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . handler) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (handler))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . preserve_fds) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (preserve_fds))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . listen_fds) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (listen_fds))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . output_handler) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (output_handler))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . output_handler_arg) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (output_handler_arg))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . fifo_exec_wait_fd) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (fifo_exec_wait_fd))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . systemd_cgroup) as usize - ptr as usize } , 84usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (systemd_cgroup))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . detach) as usize - ptr as usize } , 85usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (detach))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . no_new_keyring) as usize - ptr as usize } , 86usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (no_new_keyring))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . force_no_cgroup) as usize - ptr as usize } , 87usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (force_no_cgroup))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . no_pivot) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (no_pivot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . argv) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (argv))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . argc) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (argc))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . handler_manager) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (libcrun_context_s) , "::" , stringify ! (handler_manager))) ; } pub const LIBCRUN_RUN_OPTIONS_PREFORK : _bindgen_ty_5 = 1 ; pub const LIBCRUN_RUN_OPTIONS_KEEP : _bindgen_ty_5 = 2 ; pub type _bindgen_ty_5 = :: std :: os :: raw :: c_uint ; pub const LIBCRUN_CREATE_OPTIONS_PREFORK : _bindgen_ty_6 = 1 ; pub type _bindgen_ty_6 = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_container_s { pub container_def : * mut runtime_spec_schema_config_schema , pub host_uid : uid_t , pub host_gid : gid_t , pub container_uid : uid_t , pub container_gid : gid_t , pub config_file : * mut :: std :: os :: raw :: c_char , pub config_file_content : * mut :: std :: os :: raw :: c_char , pub private_data : * mut :: std :: os :: raw :: c_void , pub cleanup_private_data : :: std :: option :: Option < unsafe extern "C" fn (private_data : * mut :: std :: os :: raw :: c_void) > , pub context : * mut libcrun_context_s , } # [test] fn bindgen_test_layout_libcrun_container_s () { const UNINIT : :: std :: mem :: MaybeUninit < libcrun_container_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < libcrun_container_s > () , 64usize , concat ! ("Size of: " , stringify ! (libcrun_container_s))) ; assert_eq ! (:: std :: mem :: align_of :: < libcrun_container_s > () , 8usize , concat ! ("Alignment of " , stringify ! (libcrun_container_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . container_def) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (container_def))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . host_uid) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (host_uid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . host_gid) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (host_gid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . container_uid) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (container_uid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . container_gid) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (container_gid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . config_file) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (config_file))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . config_file_content) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (config_file_content))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . private_data) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (private_data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cleanup_private_data) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (cleanup_private_data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . context) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_s) , "::" , stringify ! (context))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_container_status_s { _unused : [u8 ; 0] , } pub type libcrun_container_status_t = libcrun_container_status_s ; pub type libcrun_container_t = libcrun_container_s ; pub type libcrun_context_t = libcrun_context_s ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct container_entrypoint_s { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct cgroup_info_s { pub v1 : bool , pub v2 : bool , pub systemd : bool , pub systemd_user : bool , } # [test] fn bindgen_test_layout_cgroup_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < cgroup_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < cgroup_info_s > () , 4usize , concat ! ("Size of: " , stringify ! (cgroup_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < cgroup_info_s > () , 1usize , concat ! ("Alignment of " , stringify ! (cgroup_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v1) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (cgroup_info_s) , "::" , stringify ! (v1))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v2) as usize - ptr as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (cgroup_info_s) , "::" , stringify ! (v2))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . systemd) as usize - ptr as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (cgroup_info_s) , "::" , stringify ! (systemd))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . systemd_user) as usize - ptr as usize } , 3usize , concat ! ("Offset of field: " , stringify ! (cgroup_info_s) , "::" , stringify ! (systemd_user))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct seccomp_info_s { pub enabled : bool , pub actions : * mut * mut :: std :: os :: raw :: c_char , pub operators : * mut * mut :: std :: os :: raw :: c_char , pub archs : * mut * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_seccomp_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < seccomp_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < seccomp_info_s > () , 32usize , concat ! ("Size of: " , stringify ! (seccomp_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < seccomp_info_s > () , 8usize , concat ! ("Alignment of " , stringify ! (seccomp_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . enabled) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (seccomp_info_s) , "::" , stringify ! (enabled))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . actions) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (seccomp_info_s) , "::" , stringify ! (actions))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . operators) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (seccomp_info_s) , "::" , stringify ! (operators))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . archs) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (seccomp_info_s) , "::" , stringify ! (archs))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct apparmor_info_s { pub enabled : bool , } # [test] fn bindgen_test_layout_apparmor_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < apparmor_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < apparmor_info_s > () , 1usize , concat ! ("Size of: " , stringify ! (apparmor_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < apparmor_info_s > () , 1usize , concat ! ("Alignment of " , stringify ! (apparmor_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . enabled) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (apparmor_info_s) , "::" , stringify ! (enabled))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct selinux_info_s { pub enabled : bool , } # [test] fn bindgen_test_layout_selinux_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < selinux_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < selinux_info_s > () , 1usize , concat ! ("Size of: " , stringify ! (selinux_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < selinux_info_s > () , 1usize , concat ! ("Alignment of " , stringify ! (selinux_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . enabled) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (selinux_info_s) , "::" , stringify ! (enabled))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct idmap_info_s { pub enabled : bool , } # [test] fn bindgen_test_layout_idmap_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < idmap_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < idmap_info_s > () , 1usize , concat ! ("Size of: " , stringify ! (idmap_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < idmap_info_s > () , 1usize , concat ! ("Alignment of " , stringify ! (idmap_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . enabled) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (idmap_info_s) , "::" , stringify ! (enabled))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct intel_rdt_s { pub enabled : bool , } # [test] fn bindgen_test_layout_intel_rdt_s () { const UNINIT : :: std :: mem :: MaybeUninit < intel_rdt_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < intel_rdt_s > () , 1usize , concat ! ("Size of: " , stringify ! (intel_rdt_s))) ; assert_eq ! (:: std :: mem :: align_of :: < intel_rdt_s > () , 1usize , concat ! ("Alignment of " , stringify ! (intel_rdt_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . enabled) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (intel_rdt_s) , "::" , stringify ! (enabled))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mount_ext_info_s { pub idmap : idmap_info_s , } # [test] fn bindgen_test_layout_mount_ext_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < mount_ext_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mount_ext_info_s > () , 1usize , concat ! ("Size of: " , stringify ! (mount_ext_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < mount_ext_info_s > () , 1usize , concat ! ("Alignment of " , stringify ! (mount_ext_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . idmap) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mount_ext_info_s) , "::" , stringify ! (idmap))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct linux_info_s { pub namespaces : * mut * mut :: std :: os :: raw :: c_char , pub capabilities : * mut * mut :: std :: os :: raw :: c_char , pub cgroup : cgroup_info_s , pub seccomp : seccomp_info_s , pub apparmor : apparmor_info_s , pub selinux : selinux_info_s , pub mount_ext : mount_ext_info_s , pub intel_rdt : intel_rdt_s , } # [test] fn bindgen_test_layout_linux_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < linux_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < linux_info_s > () , 64usize , concat ! ("Size of: " , stringify ! (linux_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < linux_info_s > () , 8usize , concat ! ("Alignment of " , stringify ! (linux_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . namespaces) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (namespaces))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . capabilities) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (capabilities))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cgroup) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (cgroup))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . seccomp) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (seccomp))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . apparmor) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (apparmor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . selinux) as usize - ptr as usize } , 57usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (selinux))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mount_ext) as usize - ptr as usize } , 58usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (mount_ext))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . intel_rdt) as usize - ptr as usize } , 59usize , concat ! ("Offset of field: " , stringify ! (linux_info_s) , "::" , stringify ! (intel_rdt))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct annotations_info_s { pub io_github_seccomp_libseccomp_version : * mut :: std :: os :: raw :: c_char , pub run_oci_crun_checkpoint_enabled : bool , pub run_oci_crun_commit : * mut :: std :: os :: raw :: c_char , pub run_oci_crun_version : * mut :: std :: os :: raw :: c_char , pub run_oci_crun_wasm : bool , } # [test] fn bindgen_test_layout_annotations_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < annotations_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < annotations_info_s > () , 40usize , concat ! ("Size of: " , stringify ! (annotations_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < annotations_info_s > () , 8usize , concat ! ("Alignment of " , stringify ! (annotations_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . io_github_seccomp_libseccomp_version) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (annotations_info_s) , "::" , stringify ! (io_github_seccomp_libseccomp_version))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . run_oci_crun_checkpoint_enabled) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (annotations_info_s) , "::" , stringify ! (run_oci_crun_checkpoint_enabled))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . run_oci_crun_commit) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (annotations_info_s) , "::" , stringify ! (run_oci_crun_commit))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . run_oci_crun_version) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (annotations_info_s) , "::" , stringify ! (run_oci_crun_version))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . run_oci_crun_wasm) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (annotations_info_s) , "::" , stringify ! (run_oci_crun_wasm))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct features_info_s { pub oci_version_min : * mut :: std :: os :: raw :: c_char , pub oci_version_max : * mut :: std :: os :: raw :: c_char , pub hooks : * mut * mut :: std :: os :: raw :: c_char , pub mount_options : * mut * mut :: std :: os :: raw :: c_char , pub linux : linux_info_s , pub annotations : annotations_info_s , pub potentially_unsafe_annotations : * mut * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_features_info_s () { const UNINIT : :: std :: mem :: MaybeUninit < features_info_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < features_info_s > () , 144usize , concat ! ("Size of: " , stringify ! (features_info_s))) ; assert_eq ! (:: std :: mem :: align_of :: < features_info_s > () , 8usize , concat ! ("Alignment of " , stringify ! (features_info_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . oci_version_min) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (features_info_s) , "::" , stringify ! (oci_version_min))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . oci_version_max) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (features_info_s) , "::" , stringify ! (oci_version_max))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hooks) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (features_info_s) , "::" , stringify ! (hooks))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mount_options) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (features_info_s) , "::" , stringify ! (mount_options))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . linux) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (features_info_s) , "::" , stringify ! (linux))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . annotations) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (features_info_s) , "::" , stringify ! (annotations))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . potentially_unsafe_annotations) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (features_info_s) , "::" , stringify ! (potentially_unsafe_annotations))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_checkpoint_restore_s { pub image_path : * mut :: std :: os :: raw :: c_char , pub work_path : * mut :: std :: os :: raw :: c_char , pub leave_running : bool , pub tcp_established : bool , pub shell_job : bool , pub ext_unix_sk : bool , pub detach : bool , pub file_locks : bool , pub console_socket : * const :: std :: os :: raw :: c_char , pub parent_path : * mut :: std :: os :: raw :: c_char , pub pre_dump : bool , pub manage_cgroups_mode : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_libcrun_checkpoint_restore_s () { const UNINIT : :: std :: mem :: MaybeUninit < libcrun_checkpoint_restore_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < libcrun_checkpoint_restore_s > () , 48usize , concat ! ("Size of: " , stringify ! (libcrun_checkpoint_restore_s))) ; assert_eq ! (:: std :: mem :: align_of :: < libcrun_checkpoint_restore_s > () , 8usize , concat ! ("Alignment of " , stringify ! (libcrun_checkpoint_restore_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . image_path) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (image_path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . work_path) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (work_path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . leave_running) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (leave_running))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . tcp_established) as usize - ptr as usize } , 17usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (tcp_established))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . shell_job) as usize - ptr as usize } , 18usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (shell_job))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ext_unix_sk) as usize - ptr as usize } , 19usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (ext_unix_sk))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . detach) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (detach))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . file_locks) as usize - ptr as usize } , 21usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (file_locks))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . console_socket) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (console_socket))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . parent_path) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (parent_path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . pre_dump) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (pre_dump))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . manage_cgroups_mode) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (libcrun_checkpoint_restore_s) , "::" , stringify ! (manage_cgroups_mode))) ; } pub type libcrun_checkpoint_restore_t = libcrun_checkpoint_restore_s ; extern "C" { pub fn libcrun_container_load_from_file (path : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> * mut libcrun_container_t ; } extern "C" { pub fn libcrun_container_load_from_memory (json : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> * mut libcrun_container_t ; } extern "C" { pub fn libcrun_container_free (arg1 : * mut libcrun_container_t) ; } extern "C" { pub fn libcrun_container_run (context : * mut libcrun_context_t , container : * mut libcrun_container_t , options : :: std :: os :: raw :: c_uint , error : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_delete (context : * mut libcrun_context_t , def : * mut runtime_spec_schema_config_schema , id : * const :: std :: os :: raw :: c_char , force : bool , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_kill (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , signal : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_killall (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , signal : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_create (context : * mut libcrun_context_t , container : * mut libcrun_container_t , options : :: std :: os :: raw :: c_uint , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_start (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_state (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , out : * mut FILE , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_notify_handler (args : * mut container_entrypoint_s , phase : handler_configure_phase , container : * mut libcrun_container_t , rootfs : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_get_container_state_string (id : * const :: std :: os :: raw :: c_char , status : * mut libcrun_container_status_t , state_root : * const :: std :: os :: raw :: c_char , container_status : * mut * const :: std :: os :: raw :: c_char , running : * mut :: std :: os :: raw :: c_int , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_container_exec_options_s { pub struct_size : usize , pub process : * mut runtime_spec_schema_config_schema_process , pub path : * const :: std :: os :: raw :: c_char , pub cgroup : * const :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_libcrun_container_exec_options_s () { const UNINIT : :: std :: mem :: MaybeUninit < libcrun_container_exec_options_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < libcrun_container_exec_options_s > () , 32usize , concat ! ("Size of: " , stringify ! (libcrun_container_exec_options_s))) ; assert_eq ! (:: std :: mem :: align_of :: < libcrun_container_exec_options_s > () , 8usize , concat ! ("Alignment of " , stringify ! (libcrun_container_exec_options_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . struct_size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_exec_options_s) , "::" , stringify ! (struct_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . process) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_exec_options_s) , "::" , stringify ! (process))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . path) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_exec_options_s) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cgroup) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (libcrun_container_exec_options_s) , "::" , stringify ! (cgroup))) ; } extern "C" { pub fn libcrun_container_exec_with_options (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , opts : * mut libcrun_container_exec_options_s , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_exec (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , process : * mut runtime_spec_schema_config_schema_process , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_exec_process_file (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , path : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_update (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , content : * const :: std :: os :: raw :: c_char , len : usize , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_update_from_file (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_update_value_s { pub section : * const :: std :: os :: raw :: c_char , pub name : * const :: std :: os :: raw :: c_char , pub numeric : bool , pub value : * const :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_libcrun_update_value_s () { const UNINIT : :: std :: mem :: MaybeUninit < libcrun_update_value_s > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < libcrun_update_value_s > () , 32usize , concat ! ("Size of: " , stringify ! (libcrun_update_value_s))) ; assert_eq ! (:: std :: mem :: align_of :: < libcrun_update_value_s > () , 8usize , concat ! ("Alignment of " , stringify ! (libcrun_update_value_s))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . section) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (libcrun_update_value_s) , "::" , stringify ! (section))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . name) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (libcrun_update_value_s) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . numeric) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (libcrun_update_value_s) , "::" , stringify ! (numeric))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . value) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (libcrun_update_value_s) , "::" , stringify ! (value))) ; } extern "C" { pub fn libcrun_container_update_from_values (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , values : * mut libcrun_update_value_s , len : usize , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct libcrun_intel_rdt_update { pub l3_cache_schema : * const :: std :: os :: raw :: c_char , pub mem_bw_schema : * const :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_libcrun_intel_rdt_update () { const UNINIT : :: std :: mem :: MaybeUninit < libcrun_intel_rdt_update > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < libcrun_intel_rdt_update > () , 16usize , concat ! ("Size of: " , stringify ! (libcrun_intel_rdt_update))) ; assert_eq ! (:: std :: mem :: align_of :: < libcrun_intel_rdt_update > () , 8usize , concat ! ("Alignment of " , stringify ! (libcrun_intel_rdt_update))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . l3_cache_schema) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (libcrun_intel_rdt_update) , "::" , stringify ! (l3_cache_schema))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_bw_schema) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (libcrun_intel_rdt_update) , "::" , stringify ! (mem_bw_schema))) ; } extern "C" { pub fn libcrun_container_update_intel_rdt (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , update : * mut libcrun_intel_rdt_update , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_get_features (context : * mut libcrun_context_t , info : * mut * mut features_info_s , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_spec (root : bool , out : * mut FILE , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_pause (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_unpause (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_checkpoint (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , cr_options : * mut libcrun_checkpoint_restore_t , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_restore (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , cr_options : * mut libcrun_checkpoint_restore_t , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_container_read_pids (context : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , recurse : bool , pids : * mut * mut pid_t , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn libcrun_write_json_containers_list (context : * mut libcrun_context_t , out : * mut FILE , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn get_root_in_the_userns (def : * mut runtime_spec_schema_config_schema , host_uid : uid_t , host_gid : gid_t , uid : * mut uid_t , gid : * mut gid_t) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct crun_global_arguments { pub root : * mut :: std :: os :: raw :: c_char , pub log : * mut :: std :: os :: raw :: c_char , pub log_format : * mut :: std :: os :: raw :: c_char , pub handler : * const :: std :: os :: raw :: c_char , pub argc : :: std :: os :: raw :: c_int , pub argv : * mut * mut :: std :: os :: raw :: c_char , pub command : bool , pub debug : bool , pub option_systemd_cgroup : bool , pub option_force_no_cgroup : bool , } # [test] fn bindgen_test_layout_crun_global_arguments () { const UNINIT : :: std :: mem :: MaybeUninit < crun_global_arguments > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < crun_global_arguments > () , 56usize , concat ! ("Size of: " , stringify ! (crun_global_arguments))) ; assert_eq ! (:: std :: mem :: align_of :: < crun_global_arguments > () , 8usize , concat ! ("Alignment of " , stringify ! (crun_global_arguments))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . root) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (root))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . log) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (log))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . log_format) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (log_format))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . handler) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (handler))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . argc) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (argc))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . argv) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (argv))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . command) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (command))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . debug) as usize - ptr as usize } , 49usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (debug))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option_systemd_cgroup) as usize - ptr as usize } , 50usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (option_systemd_cgroup))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option_force_no_cgroup) as usize - ptr as usize } , 51usize , concat ! ("Offset of field: " , stringify ! (crun_global_arguments) , "::" , stringify ! (option_force_no_cgroup))) ; } extern "C" { pub fn argp_mandatory_argument (arg : * mut :: std :: os :: raw :: c_char , state : * mut [u8 ; 0usize]) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn init_libcrun_context (con : * mut libcrun_context_t , id : * const :: std :: os :: raw :: c_char , glob : * mut crun_global_arguments , err : * mut libcrun_error_t) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn crun_assert_n_args (n : :: std :: os :: raw :: c_int , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int) ; } pub type __builtin_va_list = [__va_list_tag ; 1usize] ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [test] fn bindgen_test_layout___va_list_tag () { const UNINIT : :: std :: mem :: MaybeUninit < __va_list_tag > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __va_list_tag > () , 24usize , concat ! ("Size of: " , stringify ! (__va_list_tag))) ; assert_eq ! (:: std :: mem :: align_of :: < __va_list_tag > () , 8usize , concat ! ("Alignment of " , stringify ! (__va_list_tag))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . gp_offset) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (gp_offset))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . fp_offset) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (fp_offset))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . overflow_arg_area) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (overflow_arg_area))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . reg_save_area) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (reg_save_area))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __locale_data { pub _address : u8 , }